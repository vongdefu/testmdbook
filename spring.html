<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>spring</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<p>title: Spring面试题，41道Spring八股文（1.3万字63张手绘图），面渣逆袭必看👍
shortTitle: 面渣逆袭-Spring
description: 下载次数超 1 万次，1.3 万字 63 张手绘图，详解 41 道 Spring 面试高频题（让天下没有难背的八股），面渣背会这些 Spring 八股文，这次吊打面试官，我觉得稳了（手动 dog）。
author: 三分恶
date: 2024-11-05
category:</p>
<ul>
<li>面渣逆袭
tag:</li>
<li>面渣逆袭
head:</li>
<li>
<ul>
<li>meta</li>
<li>name: keywords
content: Spring面试题,Spring,面试题,八股文,java,spring全家桶</li>
</ul>
</li>
</ul>
<hr />
<p>1.3 万字 63 张手绘图，详解 41 道 Spring 面试高频题（让天下没有难背的八股），面渣背会这些 Spring 八股文，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳<a href="https://mp.weixin.qq.com/s/EQge6DmgIqYITM3mAxkatg">转载链接</a>，作者：三分恶，戳<a href="https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ">原文链接</a>。</p>
<h2 id="基础"><a class="header" href="#基础">基础</a></h2>
<h3 id="1spring-是什么特性有哪些模块"><a class="header" href="#1spring-是什么特性有哪些模块">1.Spring 是什么？特性？有哪些模块？</a></h3>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-165c27b4-2ea0-409a-8fa5-389c105db0fa.png" alt="Spring Logo" /></p>
<p>一句话概括：<strong>Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。</strong></p>
<p>2003 年，一个音乐家 Rod Johnson 决定发展一个轻量级的 Java 开发框架，<code>Spring</code>作为 Java 战场的龙骑兵渐渐崛起，并淘汰了<code>EJB</code>这个传统的重装骑兵。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-5d9efb93-03a5-400c-8429-3be7c5eeddfb.png" alt="Spring重要版本" /></p>
<p>到了现在，企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p>
<h4 id="spring-有哪些特性呢"><a class="header" href="#spring-有哪些特性呢">Spring 有哪些特性呢？</a></h4>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-a0f0ef9d-3289-41ea-94c2-34b7e37ef854.png" alt="三分恶面渣逆袭：Spring特性" /></p>
<ol>
<li><strong>IoC</strong> 和 <strong>DI</strong> 的支持</li>
</ol>
<p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现<strong>高内聚低耦合</strong>的设计理念。</p>
<ol start="2">
<li>AOP 编程的支持</li>
</ol>
<p>Spring 提供了<strong>面向切面编程</strong>，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p>
<ol start="3">
<li>声明式事务的支持</li>
</ol>
<p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p>
<ol start="4">
<li>快捷测试的支持</li>
</ol>
<p>Spring 对 Junit 提供支持，可以通过<strong>注解</strong>快捷地测试 Spring 程序。</p>
<ol start="5">
<li>快速集成功能</li>
</ol>
<p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p>
<ol start="6">
<li>复杂 API 模板封装</li>
</ol>
<p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p>
<h4 id="简单说一下什么是aop-和-ioc"><a class="header" href="#简单说一下什么是aop-和-ioc">简单说一下什么是AOP 和 IoC？</a></h4>
<p><strong>AOP</strong>：面向切面编程，是一种编程范式，它的主要作用是将那些与核心业务逻辑无关，但是对多个对象产生影响的公共行为封装起来，如日志记录、性能统计、事务等。</p>
<p><strong>IoC</strong>：控制反转，是一种设计思想，它的主要作用是将对象的创建和对象之间的调用过程交给 Spring 容器来管理。</p>
<h4 id="spring源码看过吗"><a class="header" href="#spring源码看过吗">Spring源码看过吗？</a></h4>
<p>看过一些，主要就是针对 Spring 循环依赖、Bean 声明周期、AOP、事务、IOC 这五部分。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241207102105.png" alt="星球嘉宾楼仔：Spring 源码解析" /></p>
<p>PS：关于这份小册的 PDF 版本，目前只有<a href="https://javabetter.cn/zhishixingqiu/">星球</a>的用户可以获取，后续会考虑开放给大家。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241207101910.png" alt="楼仔的 Spring 源码解析手册" /></p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：IOC与AOP</li>
</ol>
</blockquote>
<h3 id="2spring-有哪些模块呢"><a class="header" href="#2spring-有哪些模块呢">2.Spring 有哪些模块呢？</a></h3>
<p>Spring 框架是分模块存在，除了最核心的<code>Spring Core Container</code>是必要模块之外，其他模块都是<code>可选</code>，大约有 20 多个模块。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-bb7c13ea-3174-4b32-84b8-821849ddc377.png" alt="Spring模块划分" /></p>
<p>最主要的七大模块：</p>
<ol>
<li><strong>Spring Core</strong>：Spring 核心，它是框架最基础的部分，提供 IoC 和依赖注入 DI 特性。</li>
<li><strong>Spring Context</strong>：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li>
<li><strong>Spring Web</strong>：它提供 Web 应用开发的支持。</li>
<li><strong>Spring MVC</strong>：它针对 Web 应用中 MVC 思想的实现。</li>
<li><strong>Spring DAO</strong>：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li>
<li><strong>Spring ORM</strong>：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</li>
<li><strong>Spring AOP</strong>：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li>
</ol>
<h3 id="3spring-有哪些常用注解呢"><a class="header" href="#3spring-有哪些常用注解呢">3.Spring 有哪些常用注解呢？</a></h3>
<p>Spring 提供了大量的注解来简化 Java 应用的开发和配置，主要用于 Web 开发、往容器注入 Bean、AOP、事务控制等。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-8d0a1518-a425-4887-9735-45321095d927.png" alt="三分恶面渣逆袭：Spring常用注解" /></p>
<h4 id="web-开发方面有哪些注解呢"><a class="header" href="#web-开发方面有哪些注解呢">Web 开发方面有哪些注解呢？</a></h4>
<p>①、<code>@Controller</code>：用于标注控制层组件。</p>
<p>②、<code>@RestController</code>：是<code>@Controller</code> 和 <code>@ResponseBody</code> 的结合体，返回 JSON 数据时使用。</p>
<p>③、<code>@RequestMapping</code>：用于映射请求 URL 到具体的方法上，还可以细分为：</p>
<ul>
<li><code>@GetMapping</code>：只能用于处理 GET 请求</li>
<li><code>@PostMapping</code>：只能用于处理 POST 请求</li>
<li><code>@DeleteMapping</code>：只能用于处理 DELETE 请求</li>
</ul>
<p>④、<code>@ResponseBody</code>：直接将返回的数据放入 HTTP 响应正文中，一般用于返回 JSON 数据。</p>
<p>⑤、<code>@RequestBody</code>：表示一个方法参数应该绑定到 Web 请求体。</p>
<p>⑥、<code>@PathVariable</code>：用于接收路径参数，比如 <code>@RequestMapping(“/hello/{name}”)</code>，这里的 name 就是路径参数。</p>
<p>⑦、<code>@RequestParam</code>：用于接收请求参数。比如 <code>@RequestParam(name = "key") String key</code>，这里的 key 就是请求参数。</p>
<h4 id="容器类注解有哪些呢"><a class="header" href="#容器类注解有哪些呢">容器类注解有哪些呢？</a></h4>
<ul>
<li><code>@Component</code>：标识一个类为 Spring 组件，使其能够被 Spring 容器自动扫描和管理。</li>
<li><code>@Service</code>：标识一个业务逻辑组件（服务层）。比如 <code>@Service("userService")</code>，这里的 userService 就是 Bean 的名称。</li>
<li><code>@Repository</code>：标识一个数据访问组件（持久层）。</li>
<li><code>@Autowired</code>：按类型自动注入依赖。</li>
<li><code>@Configuration</code>：用于定义配置类，可替换 XML 配置文件。</li>
<li><code>@Value</code>：用于将 Spring Boot 中 application.properties 配置的属性值赋值给变量。</li>
</ul>
<h4 id="aop-方面有哪些注解呢"><a class="header" href="#aop-方面有哪些注解呢">AOP 方面有哪些注解呢？</a></h4>
<p><code>@Aspect</code> 用于声明一个切面，可以配合其他注解一起使用，比如：</p>
<ul>
<li><code>@After</code>：在方法执行之后执行。</li>
<li><code>@Before</code>：在方法执行之前执行。</li>
<li><code>@Around</code>：方法前后均执行。</li>
<li><code>@PointCut</code>：定义切点，指定需要拦截的方法。</li>
</ul>
<h4 id="事务注解有哪些"><a class="header" href="#事务注解有哪些">事务注解有哪些？</a></h4>
<p>主要就是 <code>@Transactional</code>，用于声明一个方法需要事务支持。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的微众银行同学 1 Java 后端一面的原题：说说 Spring 常见的注解？</li>
</ol>
</blockquote>
<h3 id="4spring-中应用了哪些设计模式呢"><a class="header" href="#4spring-中应用了哪些设计模式呢">4.Spring 中应用了哪些设计模式呢？</a></h3>
<p>Spring 框架中用了蛮多设计模式的：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-ee1c5cee-8462-4bae-93ea-ec936cc77640.png" alt="三分恶面渣逆袭：Spring中用到的设计模式" /></p>
<p>①、比如说工厂模式用于 BeanFactory 和 ApplicationContext，实现 Bean 的创建和管理。</p>
<pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
MyBean myBean = context.getBean(MyBean.class);
</code></pre>
<p>②、比如说单例模式，这样可以保证 Bean 的唯一性，减少系统开销。</p>
<pre><code class="language-java">ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
MyService myService1 = context.getBean(MyService.class);
MyService myService2 = context.getBean(MyService.class);

// This will print "true" because both references point to the same instance
System.out.println(myService1 == myService2);
</code></pre>
<p>③、比如说 AOP 使用了代理模式来实现横切关注点（如事务管理、日志记录、权限控制等）。</p>
<pre><code class="language-java">@Transactional
public void myTransactionalMethod() {
    // 方法实现
}
</code></pre>
<h4 id="spring如何实现单例模式"><a class="header" href="#spring如何实现单例模式">Spring如何实现单例模式？</a></h4>
<p>Spring 通过 IOC 容器实现单例模式，具体步骤是：</p>
<p>单例 Bean 在容器初始化时创建并使用 DefaultSingletonBeanRegistry 提供的 singletonObjects 进行缓存。</p>
<pre><code class="language-java">// 单例缓存
private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;();

public Object getSingleton(String beanName) {
    return this.singletonObjects.get(beanName);
}

protected void addSingleton(String beanName, Object singletonObject) {
    this.singletonObjects.put(beanName, singletonObject);
}
</code></pre>
<p>在请求 Bean 时，Spring 会先从缓存中获取。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的携程面经同学 10 Java 暑期实习一面面试原题：Spring IoC 的设计模式，AOP 的设计模式</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经合集同学 1 Java 后端面试原题：Spring 框架使用到的设计模式？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的同学 1 贝壳找房后端技术一面面试原题：Spring用了什么设计模式？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：Spring中使用了哪些设计模式，以其中一种模式举例说明？Spring如何实现单例模式？</li>
</ol>
</blockquote>
<h3 id="39spring-容器web-容器之间的区别补充"><a class="header" href="#39spring-容器web-容器之间的区别补充">39.Spring 容器、Web 容器之间的区别？（补充）</a></h3>
<blockquote>
<p>2024 年 7 月 11 日增补</p>
</blockquote>
<p>Spring 容器是 Spring 框架的核心部分，负责管理应用程序中的对象生命周期和依赖注入。</p>
<p>Web 容器（也称 Servlet 容器），是用于运行 Java Web 应用程序的服务器环境，支持 Servlet、JSP 等 Web 组件。常见的 Web 容器包括 Apache Tomcat、Jetty等。</p>
<p>Spring MVC 是 Spring 框架的一部分，专门用于处理 Web 请求，基于 MVC（Model-View-Controller）设计模式。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的去哪儿同学 1 技术二面原题：spring的容器、web容器、springmvc的容器之间的区别</li>
</ol>
</blockquote>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="ioc"><a class="header" href="#ioc">IoC</a></h2>
<h3 id="5说一说什么是-iocdi"><a class="header" href="#5说一说什么是-iocdi">5.说一说什么是 IoC、DI？</a></h3>
<p>推荐阅读：<a href="https://javabetter.cn/springboot/ioc.html">IoC 扫盲</a></p>
<p>所谓的<strong>IoC</strong>，就是由容器来控制对象的生命周期和对象之间的关系。控制对象生命周期的不再是引用它的对象，而是容器，这就叫<strong>控制反转</strong>（Inversion of Control）。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-440f5d0e-f4db-462c-97fb-d54407a354d5.png" alt="三分恶面渣逆袭：控制反转示意图" /></p>
<p>以前是我们想要什么就自己创建什么，现在是我们需要什么容器就帮我们送来什么。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-619da277-c15e-4dd7-9f2b-dbd809a9aaa0.png" alt="引入IoC之前和引入IoC之后" /></p>
<p>没有 IoC 之前：</p>
<blockquote>
<p>我需要一个女朋友，刚好大街上突然看到了一个小姐姐，人很好看，于是我就自己主动上去搭讪，要她的微信号，找机会聊天关心她，然后约她出来吃饭，打听她的爱好，三观。。。</p>
</blockquote>
<p>有了 IoC 之后：</p>
<blockquote>
<p>我需要一个女朋友，于是我就去找婚介所，告诉婚介所，我需要一个长的像赵露思的，会打 Dota2 的，于是婚介所在它的人才库里开始找，找不到它就直接说没有，找到它就直接介绍给我。</p>
</blockquote>
<p>婚介所就相当于一个 IoC 容器，我就是一个对象，我需要的女朋友就是另一个对象，我不用关心女朋友是怎么来的，我只需要告诉婚介所我需要什么样的女朋友，婚介所就帮我去找。</p>
<p>Spring 倡导的开发方式就是这样，所有类的创建和销毁都通过 Spring 容器来，不再是开发者去 new，去 <code>= null</code>，这样就实现了对象的解耦。</p>
<p>于是，对于某个对象来说，以前是它控制它依赖的对象，现在是所有对象都被 Spring 控制。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240310191630.png" alt="图片来源于网络" /></p>
<h4 id="说说什么是-di"><a class="header" href="#说说什么是-di">说说什么是 DI？</a></h4>
<p>IOC 是一种思想，DI 是实现 IOC 的具体方式，比如说利用注入机制（如构造器注入、Setter 注入）将依赖传递给目标对象。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241117132929.png" alt="Martin Fowler’s Definition" /></p>
<p>2004 年，Martin Fowler 在他的文章《控制反转容器&amp;依赖注入模式》首次提出了 <strong>DI（依赖注入，Dependency Injection）</strong> 这个名词。</p>
<p>打个比方，你现在想吃韭菜馅的饺子，这时候就有人用针管往你吃的饺子里注入韭菜鸡蛋馅。就好像 A 类需要 B 类，以前是 A 类自己 new 一个 B 类，现在是有人把 B 类注入到 A 类里。</p>
<h4 id="为什么要使用-ioc-呢"><a class="header" href="#为什么要使用-ioc-呢">为什么要使用 IoC 呢？</a></h4>
<p>在平时的 Java 开发中，如果我们要实现某一个功能，可能至少需要两个以上的对象来协助完成，在没有 Spring 之前，每个对象在需要它的合作对象时，需要自己 new 一个，比如说 A 要使用 B，A 就对 B 产生了依赖，也就是 A 和 B 之间存在了一种耦合关系。</p>
<p>有了 Spring 之后，就不一样了，创建 B 的工作交给了 Spring 来完成，Spring 创建好了 B 对象后就放到容器中，A 告诉 Spring 我需要 B，Spring 就从容器中取出 B 交给 A 来使用。</p>
<p>至于 B 是怎么来的，A 就不再关心了，Spring 容器想通过 newnew 创建 B 还是 new 创建 B，无所谓。</p>
<p>这就是 IoC 的好处，它降低了对象之间的耦合度，使得程序更加灵活，更加易于维护。</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html">孤傲苍狼：谈谈对 Spring IOC 的理解</a></p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：说说你对 AOP 和 IoC 的理解。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经合集同学 1 Java 后端面试原题：介绍 Spring IoC 和 AOP?</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的招商银行面经同学 6 招银网络科技面试原题：SpringBoot框架的AOP、IOC/DI？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 8 面试原题：IOC，AOP</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：解释下什么是IOC和AOP？分别解决了什么问题？IOC和DI的区别？</li>
</ol>
</blockquote>
<h3 id="6能简单说一下-spring-ioc-的实现机制吗"><a class="header" href="#6能简单说一下-spring-ioc-的实现机制吗">6.能简单说一下 Spring IoC 的实现机制吗？</a></h3>
<p>PS:这道题老三在面试中被问到过，问法是“<strong>你有自己实现过简单的 Spring 吗？</strong>”</p>
<p>Spring 的 IoC 本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-7678c40f-a48d-4bd5-80f8-e902ad688e11.png" alt="工厂运行" /></p>
<ul>
<li>
<p><strong>生产产品</strong>：一个工厂最核心的功能就是生产产品。在 Spring 里，不用 Bean 自己来实例化，而是交给 Spring，应该怎么实现呢？——答案毫无疑问，<strong>反射</strong>。</p>
<p>那么这个厂子的生产管理是怎么做的？你应该也知道——<strong>工厂模式</strong>。</p>
</li>
<li>
<p><strong>库存产品</strong>：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring 我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p>
</li>
<li>
<p><strong>订单处理</strong>：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。</p>
<p>在 Spring 里，也有这样的订单，它就是我们 bean 的定义和依赖关系，可以是 xml 形式，也可以是我们最熟悉的注解形式。</p>
</li>
</ul>
<p>我们简单地实现一个 mini 版的 Spring IoC：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-1d55c63d-2d12-43b1-9f43-428f5f4a1413.png" alt="mini版本Spring IoC" /></p>
<p><strong>Bean 定义：</strong></p>
<p>Bean 通过一个配置文件定义，把它解析成一个类型。</p>
<ul>
<li>
<p>beans.properties</p>
<p>偷懒，这里直接用了最方便解析的 properties，这里直接用一个<code>&lt;key,value&gt;</code>类型的配置来代表 Bean 的定义，其中 key 是 beanName，value 是 class</p>
<pre><code class="language-java">userDao:cn.fighter3.bean.UserDao
</code></pre>
</li>
<li>
<p>BeanDefinition.java</p>
<p>bean 定义类，配置文件中 bean 定义对应的实体</p>
<pre><code class="language-java">public class BeanDefinition {

    private String beanName;

    private Class beanClass;
     //省略getter、setter
 }
</code></pre>
</li>
<li>
<p>ResourceLoader.java</p>
<p>资源加载器，用来完成配置文件中配置的加载</p>
<pre><code class="language-java">public class ResourceLoader {

    public static Map&lt;String, BeanDefinition&gt; getResource() {
        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;&gt;(16);
        Properties properties = new Properties();
        try {
            InputStream inputStream = ResourceLoader.class.getResourceAsStream("/beans.properties");
            properties.load(inputStream);
            Iterator&lt;String&gt; it = properties.stringPropertyNames().iterator();
            while (it.hasNext()) {
                String key = it.next();
                String className = properties.getProperty(key);
                BeanDefinition beanDefinition = new BeanDefinition();
                beanDefinition.setBeanName(key);
                Class clazz = Class.forName(className);
                beanDefinition.setBeanClass(clazz);
                beanDefinitionMap.put(key, beanDefinition);
            }
            inputStream.close();
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return beanDefinitionMap;
    }

}
</code></pre>
</li>
<li>
<p>BeanRegister.java</p>
<p>对象注册器，这里用于单例 bean 的缓存，我们大幅简化，默认所有 bean 都是单例的。可以看到所谓单例注册，也很简单，不过是往 HashMap 里存对象。</p>
<pre><code class="language-java">public class BeanRegister {

    //单例Bean缓存
    private Map&lt;String, Object&gt; singletonMap = new HashMap&lt;&gt;(32);

    /**
     * 获取单例Bean
     *
     * @param beanName bean名称
     * @return
     */
    public Object getSingletonBean(String beanName) {
        return singletonMap.get(beanName);
    }

    /**
     * 注册单例bean
     *
     * @param beanName
     * @param bean
     */
    public void registerSingletonBean(String beanName, Object bean) {
        if (singletonMap.containsKey(beanName)) {
            return;
        }
        singletonMap.put(beanName, bean);
    }

}
</code></pre>
</li>
<li>
<p><strong>BeanFactory.java</strong></p>
</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-c6b3b707-cf53-4c7c-a6f9-8560950806fc.png" alt="BeanFactory" /></p>
<ul>
<li>
<p>对象工厂，我们最<strong>核心</strong>的一个类，在它初始化的时候，创建了 bean 注册器，完成了资源的加载。</p>
</li>
<li>
<p>获取 bean 的时候，先从单例缓存中取，如果没有取到，就创建并注册一个 bean</p>
<pre><code class="language-java">public class BeanFactory {

    private Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new HashMap&lt;&gt;();

    private BeanRegister beanRegister;

    public BeanFactory() {
        //创建bean注册器
        beanRegister = new BeanRegister();
        //加载资源
        this.beanDefinitionMap = new ResourceLoader().getResource();
    }

    /**
     * 获取bean
     *
     * @param beanName bean名称
     * @return
     */
    public Object getBean(String beanName) {
        //从bean缓存中取
        Object bean = beanRegister.getSingletonBean(beanName);
        if (bean != null) {
            return bean;
        }
        //根据bean定义，创建bean
        return createBean(beanDefinitionMap.get(beanName));
    }

    /**
     * 创建Bean
     *
     * @param beanDefinition bean定义
     * @return
     */
    private Object createBean(BeanDefinition beanDefinition) {
        try {
            Object bean = beanDefinition.getBeanClass().newInstance();
            //缓存bean
            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);
            return bean;
        } catch (InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>
</li>
<li>
<p>测试</p>
<ul>
<li>
<p>UserDao.java</p>
<p>我们的 Bean 类，很简单</p>
<pre><code class="language-java">public class UserDao {

    public void queryUserInfo(){
        System.out.println("A good man.");
    }
}
</code></pre>
</li>
<li>
<p>单元测试</p>
<pre><code class="language-java">public class ApiTest {
    @Test
    public void test_BeanFactory() {
        //1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)
        BeanFactory beanFactory = new BeanFactory();

        //2.第一次获取bean（通过反射创建bean，缓存bean）
        UserDao userDao1 = (UserDao) beanFactory.getBean("userDao");
        userDao1.queryUserInfo();

        //3.第二次获取bean（从缓存中获取bean）
        UserDao userDao2 = (UserDao) beanFactory.getBean("userDao");
        userDao2.queryUserInfo();
    }
}
</code></pre>
</li>
<li>
<p>运行结果</p>
<pre><code class="language-java">A good man.
A good man.
</code></pre>
</li>
</ul>
</li>
</ul>
<p>至此，我们一个乞丐+破船版的 Spring 就完成了，代码也比较完整，有条件的可以跑一下。</p>
<p>PS:因为时间+篇幅的限制，这个 demo 比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足，感兴趣可以学习参考[15]。</p>
<h3 id="7说说-beanfactory-和-applicantcontext"><a class="header" href="#7说说-beanfactory-和-applicantcontext">7.说说 BeanFactory 和 ApplicantContext?</a></h3>
<p>可以这么比喻，BeanFactory 是 Spring 的“心脏”，而 ApplicantContext 是 Spring 的完整“身躯”。</p>
<ul>
<li>BeanFactory 主要负责配置、创建和管理 bean，为 Spring 提供了基本的依赖注入（DI）支持。</li>
<li>ApplicationContext 是 BeanFactory 的子接口，在 BeanFactory 的基础上添加了企业级的功能支持。</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-66328446-f89f-4b7a-8d9f-0e1145dd9b2f.png" alt="三分恶面渣逆袭：BeanFactory和ApplicantContext" /></p>
<h4 id="详细说说-beanfactory"><a class="header" href="#详细说说-beanfactory">详细说说 BeanFactory</a></h4>
<p>BeanFactory 位于整个 Spring IoC 容器的顶端，ApplicationContext 算是 BeanFactory 的子接口。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-6e6d4b69-f36c-41e6-b8ba-9277be147c9b.png" alt="三分恶面渣逆袭：Spring5 BeanFactory继承体系" /></p>
<p>它最主要的方法就是 <code>getBean()</code>，这个方法负责从容器中返回特定名称或者类型的 Bean 实例。</p>
<p>来看一个 XMLBeanFactory（已过时） 获取 bean 的例子：</p>
<pre><code class="language-java">class HelloWorldApp{
   public static void main(String[] args) {
      BeanFactory factory = new XmlBeanFactory (new ClassPathResource("beans.xml"));
      HelloWorld obj = (HelloWorld) factory.getBean("itwanger");
      obj.getMessage();
   }
}
</code></pre>
<h4 id="请详细说说-applicationcontext"><a class="header" href="#请详细说说-applicationcontext">请详细说说 ApplicationContext</a></h4>
<p>ApplicationContext 继承了 HierachicalBeanFactory 和 ListableBeanFactory 接口，算是 BeanFactory 的自动挡版本，是 Spring 应用的默认方式。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e201c9a3-f23c-4768-b844-ac7e0ba4bcec.png" alt="三分恶面渣逆袭：Spring5 ApplicationContext部分体系类图" /></p>
<p>ApplicationContext 会在启动时预先创建和配置所有的单例 bean，并支持如 JDBC、ORM 框架的集成，内置面向切面编程（AOP）的支持，可以配置声明式事务管理等。</p>
<p>这是 ApplicationContext 的使用例子：</p>
<pre><code class="language-java">class MainApp {
    public static void main(String[] args) {
        // 使用 AppConfig 配置类初始化 ApplicationContext
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

        // 从 ApplicationContext 获取 messageService 的 bean
        MessageService service = context.getBean(MessageService.class);

        // 使用 bean
        service.printMessage();
    }
}
</code></pre>
<p>通过 AnnotationConfigApplicationContext 类，我们可以使用 Java 配置类来初始化 ApplicationContext，这样就可以使用 Java 代码来配置 Spring 容器。</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = "com.github.paicoding.forum.test.javabetter.spring1") // 替换为你的包名
public class AppConfig {
}
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 2 优选物流调度技术 2 面面试原题：BeanFactory和ApplicationContext</li>
</ol>
</blockquote>
<h3 id="8你知道-spring-容器启动阶段会干什么吗"><a class="header" href="#8你知道-spring-容器启动阶段会干什么吗">8.你知道 Spring 容器启动阶段会干什么吗？</a></h3>
<p>Spring 的 IoC 容器工作的过程，其实可以划分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean 实例化阶段</strong>。</p>
<p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的 Bean 定义中。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-8f8103f7-2a51-4858-856e-96a4ac400d76.png" alt="容器启动和Bean实例化阶段" /></p>
<p>容器启动开始，首先会通过某种途径加载 Configuration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的 Configuration MetaData 进行解析和分析，并将分析后的信息组为相应的 BeanDefinition。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-dfb3d8c4-ba8d-4a2c-aef2-4ad425f7180c.png" alt="xml配置信息映射注册过程" /></p>
<p>最后把这些保存了 Bean 定义必要信息的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器启动就完成了。</p>
<h4 id="说说-spring-的-bean-实例化方式"><a class="header" href="#说说-spring-的-bean-实例化方式">说说 Spring 的 Bean 实例化方式</a></h4>
<p>Spring 提供了 4 种不同的方式来实例化 Bean，以满足不同场景下的需求。</p>
<h4 id="说说构造方法的方式"><a class="header" href="#说说构造方法的方式">说说构造方法的方式</a></h4>
<p>在类上使用@Component（或@Service、@Repository 等特定于场景的注解）标注类，然后通过构造方法注入依赖。</p>
<pre><code class="language-java">@Component
public class ExampleBean {
    private DependencyBean dependency;

    @Autowired
    public ExampleBean(DependencyBean dependency) {
        this.dependency = dependency;
    }
}
</code></pre>
<h4 id="说说静态工厂的方式"><a class="header" href="#说说静态工厂的方式">说说静态工厂的方式</a></h4>
<p>在这种方式中，Bean 是由一个静态方法创建的，而不是直接通过构造方法。</p>
<pre><code class="language-java">public class ClientService {
    private static ClientService clientService = new ClientService();

    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}
</code></pre>
<h4 id="说说实例工厂方法实例化的方式"><a class="header" href="#说说实例工厂方法实例化的方式">说说实例工厂方法实例化的方式</a></h4>
<p>与静态工厂方法相比，实例工厂方法依赖于某个类的实例来创建 Bean。这通常用在需要通过工厂对象的非静态方法来创建 Bean 的场景。</p>
<pre><code class="language-java">public class ServiceLocator {
    public ClientService createClientServiceInstance() {
        return new ClientService();
    }
}
</code></pre>
<h4 id="说说-factorybean-接口实例化方式"><a class="header" href="#说说-factorybean-接口实例化方式">说说 FactoryBean 接口实例化方式</a></h4>
<p>FactoryBean 是一个特殊的 Bean 类型，可以在 Spring 容器中返回其他对象的实例。通过实现 FactoryBean 接口，可以自定义实例化逻辑，这对于构建复杂的初始化逻辑非常有用。</p>
<pre><code class="language-java">public class ToolFactoryBean implements FactoryBean&lt;Tool&gt; {
    private int factoryId;
    private int toolId;

    @Override
    public Tool getObject() throws Exception {
        return new Tool(toolId);
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return Tool.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }

    // setter and getter methods for factoryId and toolId
}
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：说说 Spring 的 Bean 实例化方式</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 2 优选物流调度技术 2 面面试原题：bean加工有哪些方法？</li>
</ol>
</blockquote>
<h3 id="9你是怎么理解-bean-的"><a class="header" href="#9你是怎么理解-bean-的">9.你是怎么理解 Bean 的？</a></h3>
<p>Bean 是指由 Spring 容器管理的对象，它的生命周期由容器控制，包括创建、初始化、使用和销毁。以通过三种方式声明：<strong>注解方式</strong>、<strong>XML 配置</strong>、<strong>Java 配置</strong>。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241224163146.png" alt="二哥的 Java 进阶之路：Bean 的声明方式" /></p>
<p>①、使用 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解定义，主流。</p>
<p>②、基于 XML 配置，Spring Boot 项目已经不怎么用了。</p>
<p>③、使用 Java 配置类创建 Bean：</p>
<pre><code class="language-java">@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }
}
</code></pre>
<h4 id="component-和-bean-的区别"><a class="header" href="#component-和-bean-的区别">@Component 和 @Bean 的区别</a></h4>
<p><code>@Component</code> 是 Spring 提供的一个类级别注解，由 Spring 自动扫描并注册到 Spring 容器中。</p>
<p><code>@Bean</code> 是一个方法级别的注解，用于显式地声明一个 Bean，当我们需要第三方库或者无法使用 <code>@Component</code> 注解类时，可以使用 <code>@Bean</code> 来将其实例注册到容器中。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 9 面试原题：怎么理解spring的bean，@Component 和 @Bean 的区别</li>
</ol>
</blockquote>
<h3 id="10能说一下-bean-的生命周期吗"><a class="header" href="#10能说一下-bean-的生命周期吗">10.能说一下 Bean 的生命周期吗？</a></h3>
<p>推荐阅读：<a href="https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw">三分恶：Spring Bean 生命周期，好像人的一生</a></p>
<p>Bean 的生命周期大致分为五个阶段：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-595fce5b-36cb-4dcb-b08c-8205a1e98d8a.png" alt="三分恶面渣逆袭：Bean生命周期五个阶段" /></p>
<ul>
<li><strong>实例化</strong>：Spring 首先使用构造方法或者工厂方法创建一个 Bean 的实例。在这个阶段，Bean 只是一个空的 Java 对象，还未设置任何属性。</li>
<li><strong>属性赋值</strong>：Spring 将配置文件中的属性值或依赖的 Bean 注入到该 Bean 中。这个过程称为依赖注入，确保 Bean 所需的所有依赖都被注入。</li>
<li><strong>初始化</strong>：Spring 调用 afterPropertiesSet 方法，或通过配置文件指定的 init-method 方法，完成初始化。</li>
<li><strong>使用中</strong>：Bean 准备好可以使用了。</li>
<li><strong>销毁</strong>：在容器关闭时，Spring 会调用 destroy 方法，完成 Bean 的清理工作。</li>
</ul>
<h4 id="可以从源码角度讲一下吗"><a class="header" href="#可以从源码角度讲一下吗">可以从源码角度讲一下吗？</a></h4>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-942a927a-86e4-4a01-8f52-9addd89642ff.png" alt="三分恶面渣逆袭：Spring Bean生命周期" /></p>
<ul>
<li><strong>实例化</strong>：Spring 容器根据 Bean 的定义创建 Bean 的实例，相当于执行构造方法，也就是 new 一个对象。</li>
<li><strong>属性赋值</strong>：相当于执行 setter 方法为字段赋值。</li>
<li><strong>初始化</strong>：初始化阶段允许执行自定义的逻辑，比如设置某些必要的属性值、开启资源、执行预加载操作等，以确保 Bean 在使用之前是完全配置好的。</li>
<li><strong>销毁</strong>：相当于执行 <code>= null</code>，释放资源。</li>
</ul>
<p>可以在源码 <code>AbstractAutowireCapableBeanFactory</code> 中的 <code>doCreateBean</code> 方法中，看到 Bean 的前三个生命周期：</p>
<pre><code class="language-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
    }

    if (instanceWrapper == null) {
        // 实例化阶段
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);
    }

    ...

    Object exposedObject = bean;

    try {
        // 属性赋值阶段
        this.populateBean(beanName, mbd, instanceWrapper);
        // 初始化阶段
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);
    } catch (Throwable var18) {
        ...
    }

    ...
}
</code></pre>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-d2da20a3-08d0-4648-b9a3-2fff8512b159.png" alt="三分恶面渣逆袭：Bean生命周期源码追踪" /></p>
<p>源码位置，见下图：</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240311101430.png" alt="二哥的 Java 进阶之路：doCreateBean 方法源码" /></p>
<p>至于销毁，是在容器关闭的时候调用的，详见 <code>ConfigurableApplicationContext</code> 的 <code>close</code> 方法。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240311101658.png" alt="二哥的 Java 进阶之路：close 源码" /></p>
<h4 id="请在一个已有的-spring-boot-项目中通过单元测试的形式来展示-spring-bean-的生命周期"><a class="header" href="#请在一个已有的-spring-boot-项目中通过单元测试的形式来展示-spring-bean-的生命周期">请在一个已有的 Spring Boot 项目中通过单元测试的形式来展示 Spring Bean 的生命周期？</a></h4>
<p>第一步，创建一个 LifecycleDemoBean 类：</p>
<pre><code class="language-java">public class LifecycleDemoBean implements InitializingBean, DisposableBean {

    // 使用@Value注解注入属性值，这里演示了如何从配置文件中读取值
    // 如果配置文件中没有定义lifecycle.demo.bean.name，则使用默认值"default name"
    @Value("${lifecycle.demo.bean.name:default name}")
    private String name;

    // 构造方法：在Bean实例化时调用
    public LifecycleDemoBean() {
        System.out.println("LifecycleDemoBean: 实例化");
    }

    // 属性赋值：Spring通过反射调用setter方法为Bean的属性注入值
    public void setName(String name) {
        System.out.println("LifecycleDemoBean: 属性赋值");
        this.name = name;
    }

    // 使用@PostConstruct注解的方法：在Bean的属性赋值完成后调用，用于执行初始化逻辑
    @PostConstruct
    public void postConstruct() {
        System.out.println("LifecycleDemoBean: @PostConstruct（初始化）");
    }

    // 实现InitializingBean接口：afterPropertiesSet方法在@PostConstruct注解的方法之后调用
    // 用于执行更多的初始化逻辑
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("LifecycleDemoBean: afterPropertiesSet（InitializingBean）");
    }

    // 自定义初始化方法：在XML配置或Java配置中指定，执行特定的初始化逻辑
    public void customInit() {
        System.out.println("LifecycleDemoBean: customInit（自定义初始化方法）");
    }

    // 使用@PreDestroy注解的方法：在容器销毁Bean之前调用，用于执行清理工作
    @PreDestroy
    public void preDestroy() {
        System.out.println("LifecycleDemoBean: @PreDestroy（销毁前）");
    }

    // 实现DisposableBean接口：destroy方法在@PreDestroy注解的方法之后调用
    // 用于执行清理资源等销毁逻辑
    @Override
    public void destroy() throws Exception {
        System.out.println("LifecycleDemoBean: destroy（DisposableBean）");
    }

    // 自定义销毁方法：在XML配置或Java配置中指定，执行特定的清理逻辑
    public void customDestroy() {
        System.out.println("LifecycleDemoBean: customDestroy（自定义销毁方法）");
    }
}
</code></pre>
<p><strong>①、实例化</strong></p>
<p>实例化是创建 Bean 实例的过程，即在内存中为 Bean 对象分配空间。这一步是通过调用 Bean 的构造方法完成的。</p>
<pre><code class="language-java">public LifecycleDemoBean() {
    System.out.println("LifecycleDemoBean: 实例化");
}
</code></pre>
<p>在这里，当 Spring 创建 LifecycleDemoBean 的实例时，会调用其无参数的构造方法，这个过程就是实例化。</p>
<p><strong>②、属性赋值</strong></p>
<p>在实例化之后，Spring 将根据 Bean 定义中的配置信息，通过反射机制为 Bean 的属性赋值。</p>
<pre><code class="language-java">@Value("${lifecycle.demo.bean.name:default name}")
private String name;

public void setName(String name) {
    System.out.println("LifecycleDemoBean: 属性赋值");
    this.name = name;
}
</code></pre>
<p><code>@Value</code>注解和 setter 方法体现了属性赋值的过程。<code>@Value</code>注解让 Spring 注入配置值（或默认值），setter 方法则是属性赋值的具体操作。</p>
<p><strong>③、初始化</strong></p>
<p>初始化阶段允许执行自定义的初始化逻辑，比如检查必要的属性是否已经设置、开启资源等。Spring 提供了多种方式来配置初始化逻辑。</p>
<p>1、使用 <code>@PostConstruct</code> 注解的方法</p>
<pre><code class="language-java">@PostConstruct
public void postConstruct() {
    System.out.println("LifecycleDemoBean: @PostConstruct（初始化）");
}
</code></pre>
<p><code>@PostConstruct</code>注解的方法在 Bean 的所有属性都被赋值后，且用户自定义的初始化方法之前调用。</p>
<p>2、实现 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet</code> 方法</p>
<pre><code class="language-java">@Override
public void afterPropertiesSet() throws Exception {
    System.out.println("LifecycleDemoBean: afterPropertiesSet（InitializingBean）");
}
</code></pre>
<p>afterPropertiesSet 方法提供了另一种初始化 Bean 的方式，也是在所有属性赋值后调用。</p>
<p>3、自定义初始化方法</p>
<pre><code class="language-java">public void customInit() {
    System.out.println("LifecycleDemoBean: customInit（自定义初始化方法）");
}
</code></pre>
<p>需要在配置类中指定初始化方法：</p>
<pre><code class="language-java">@Bean(initMethod = "customInit")
public LifecycleDemoBean lifecycleDemoBean() {
    return new LifecycleDemoBean();
}
</code></pre>
<p><strong>④、销毁</strong></p>
<p>销毁阶段允许执行自定义的销毁逻辑，比如释放资源。类似于初始化阶段，Spring 也提供了多种方式来配置销毁逻辑。</p>
<p>1、使用 <code>@PreDestroy</code> 注解的方法</p>
<pre><code class="language-java">@PreDestroy
public void preDestroy() {
    System.out.println("LifecycleDemoBean: @PreDestroy（销毁前）");
}
</code></pre>
<p><code>@PreDestroy</code>注解的方法在 Bean 被销毁前调用。</p>
<p>2、实现 <code>DisposableBean</code> 接口的 <code>destroy</code> 方法</p>
<pre><code class="language-java">@Override
public void destroy() throws Exception {
    System.out.println("LifecycleDemoBean: destroy（DisposableBean）");
}
</code></pre>
<p>destroy 方法提供了另一种销毁 Bean 的方式，也是在 Bean 被销毁前调用。</p>
<p>3、自定义销毁方法</p>
<pre><code class="language-java">public void customDestroy() {
    System.out.println("LifecycleDemoBean: customDestroy（自定义销毁方法）");
}
</code></pre>
<p>需要在配置类中指定销毁方法：</p>
<pre><code class="language-java">@Bean(destroyMethod = "customDestroy")
public LifecycleDemoBean lifecycleDemoBean() {
    return new LifecycleDemoBean();
}
</code></pre>
<p>第二步，注册 Bean 并指定自定义初始化方法和销毁方法：</p>
<pre><code class="language-java">@Configuration
public class LifecycleDemoConfig {

    @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
    public LifecycleDemoBean lifecycleDemoBean() {
        return new LifecycleDemoBean();
    }
}
</code></pre>
<p>第三步，编写单元测试：</p>
<pre><code class="language-java">@SpringBootTest
public class LifecycleDemoTest {

    @Autowired
    private ApplicationContext context;

    @Test
    public void testBeanLifecycle() {
        System.out.println("获取LifecycleDemoBean实例...");
        LifecycleDemoBean bean = context.getBean(LifecycleDemoBean.class);
    }
}
</code></pre>
<p>运行单元测试，查看控制台输出：</p>
<pre><code class="language-java">LifecycleDemoBean: 实例化
LifecycleDemoBean: @PostConstruct（初始化）
LifecycleDemoBean: afterPropertiesSet（InitializingBean）
LifecycleDemoBean: customInit（自定义初始化方法）
获取LifecycleDemoBean实例...
LifecycleDemoBean: @PreDestroy（销毁前）
LifecycleDemoBean: destroy（DisposableBean）
LifecycleDemoBean: customDestroy（自定义销毁方法）
</code></pre>
<h4 id="aware-类型的接口有什么作用"><a class="header" href="#aware-类型的接口有什么作用">Aware 类型的接口有什么作用？</a></h4>
<p>通过实现 Aware 接口，Bean 可以获取 Spring 容器的相关信息，如 BeanFactory、ApplicationContext 等。</p>
<p>常见 Aware 接口有：
接口|	作用
---|---
BeanNameAware|	获取当前 Bean 的名称。
BeanFactoryAware|	获取当前 Bean 所在的 BeanFactory 实例，可以直接操作容器。
ApplicationContextAware|	获取当前 Bean 所在的 ApplicationContext 实例。
EnvironmentAware|	获取 Environment 对象，用于获取配置文件中的属性或环境变量。
ServletContextAware|	在 Web 环境下获取 ServletContext 实例，访问 Web 应用上下文。
ResourceLoaderAware|	获取 ResourceLoader 对象，用于加载资源文件（如类路径文件或 URL）。</p>
<h4 id="如果配置了-init-method-和-destroy-methodspring-会在什么时候调用其配置的方法"><a class="header" href="#如果配置了-init-method-和-destroy-methodspring-会在什么时候调用其配置的方法">如果配置了 init-method 和 destroy-method，Spring 会在什么时候调用其配置的方法？</a></h4>
<p>init-method 在 Bean 初始化阶段调用，依赖注入完成后且 postProcessBeforeInitialization 调用之后执行。</p>
<p>destroy-method 在 Bean 销毁阶段调用，容器关闭时调用。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241117135852.png" alt="二哥的Java 进阶之路：init-method 和 destroy-method" /></p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：说说 Bean 的生命周期</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：Spring中bean生命周期</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的8 后端开发秋招一面面试原题：讲一下Spring Bean的生命周期</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的同学 1 贝壳找房后端技术一面面试原题：bean生命周期</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：介绍下Bean的生命周期？Aware类型接口的作用？如果配置了init-method和destroy-method，Spring会在什么时候调用其配置的方法？</li>
</ol>
</blockquote>
<h3 id="11为什么-idea-不推荐使用-autowired-注解注入-bean"><a class="header" href="#11为什么-idea-不推荐使用-autowired-注解注入-bean">11.为什么 IDEA 不推荐使用 @Autowired 注解注入 Bean？</a></h3>
<p>当使用 <code>@Autowired</code> 注解注入 Bean 时，IDEA 会提示“Field injection is not recommended”。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241224164722.png" alt="二哥的 Java 进阶之路：@Autowired" /></p>
<p>这是因为字段注入的方式：</p>
<ul>
<li>不能像构造方法那样使用 final 注入不可变对象</li>
<li>隐藏了依赖关系，调用者可以看到构造方法注入或者 setter 注入，但无法看到私有字段的注入</li>
</ul>
<p>在 Spring 4.3 及更高版本中，如果一个类只有一个构造方法，Spring 会自动使用该构造方法进行依赖注入，无需使用 <code>@Autowired</code> 注解。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241224165628.png" alt="技术派：构造方法注入" /></p>
<h4 id="autowired-和-resource-注解的区别"><a class="header" href="#autowired-和-resource-注解的区别">@Autowired 和 @Resource 注解的区别？</a></h4>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，按类型（byType）注入。</li>
<li><code>@Resource</code> 是 Java EE 提供的注解，按名称（byName）注入。</li>
</ul>
<p>虽然 IDEA 不推荐使用 <code>@Autowired</code>，但对 <code>@Resource</code> 注解却没有任何提示。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241224170055.png" alt="技术派：@Resource" /></p>
<p>这是因为 <code>@Resource</code> 属于 Java EE 标准的注解，如果使用其他 IOC 容器而不是 Spring 也是可以兼容的。</p>
<h4 id="提到了bytype如果两个类型一致的发生了冲突应该怎么处理"><a class="header" href="#提到了bytype如果两个类型一致的发生了冲突应该怎么处理">提到了byType，如果两个类型一致的发生了冲突，应该怎么处理</a></h4>
<p>当容器中存在多个相同类型的 bean，编译器会提示 <code>Could not autowire. There is more than one bean of 'UserRepository2' type.</code></p>
<pre><code class="language-java">@Component
public class UserRepository21 implements UserRepository2 {}

@Component
public class UserRepository22 implements UserRepository2 {}

@Component
public class UserService2 {
    @Autowired
    private UserRepository2 userRepository; // 冲突
}
</code></pre>
<p>这时候，就可以配合 <code>@Qualifier</code> 注解来指定具体的 bean 名称：</p>
<pre><code class="language-java">@Component("userRepository21")
public class UserRepository21 implements UserRepository2 {
}
@Component("userRepository22")
public class UserRepository22 implements UserRepository2 {
}
@Autowired
@Qualifier("userRepository22")
private UserRepository2 userRepository22;
</code></pre>
<p>或者使用 <code>@Resource</code> 注解按名称进行注入，指定 name 属性。</p>
<pre><code class="language-java">@Resource(name = "userRepository21")
private UserRepository2 userRepository21;
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 9 面试原题：依赖注入的时候，直接Autowired比较直接，为什么推荐构造方法注入呢</li>
</ol>
</blockquote>
<h3 id="12spring-有哪些自动装配的方式"><a class="header" href="#12spring-有哪些自动装配的方式">12.Spring 有哪些自动装配的方式？</a></h3>
<blockquote>
<p><strong>什么是自动装配？</strong></p>
</blockquote>
<p>Spring IoC 容器知道所有 Bean 的配置信息，此外，通过 Java 反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有 Bean 的这些信息后，Spring IoC 容器就可以按照某种规则对容器中的 Bean 进行自动装配，而无须通过显式的方式进行依赖配置。</p>
<p>Spring 提供的这种方式，可以按照某些规则进行 Bean 的自动装配，<code>&lt;bean&gt;</code>元素提供了一个指定自动装配类型的属性：<code>autowire="&lt;自动装配类型&gt;"</code></p>
<blockquote>
<p><strong>Spring 提供了哪几种自动装配类型？</strong></p>
</blockquote>
<p>Spring 提供了 4 种自动装配类型：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-034120d9-88c7-490b-af07-7d48f3b6b7bc.png" alt="Spring四种自动装配类型" /></p>
<ul>
<li><strong>byName</strong>：根据名称进行自动匹配，假设 Boss 有一个名为 car 的属性，如果容器中刚好有一个名为 car 的 bean，Spring 就会自动将其装配给 Boss 的 car 属性</li>
<li><strong>byType</strong>：根据类型进行自动匹配，假设 Boss 有一个 Car 类型的属性，如果容器中刚好有一个 Car 类型的 Bean，Spring 就会自动将其装配给 Boss 这个属性</li>
<li><strong>constructor</strong>：与 byType 类似， 只不过它是针对构造函数注入而言的。如果 Boss 有一个构造函数，构造函数包含一个 Car 类型的入参，如果容器中有一个 Car 类型的 Bean，则 Spring 将自动把这个 Bean 作为 Boss 构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的 Bean，则 Spring 将抛出异常。</li>
<li><strong>autodetect</strong>：根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 Bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。</li>
</ul>
<h3 id="13bean-的作用域有哪些"><a class="header" href="#13bean-的作用域有哪些">13.Bean 的作用域有哪些?</a></h3>
<p>在 Spring 中，Bean 默认是单例的，即在整个 Spring 容器中，每个 Bean 只有一个实例。</p>
<p>可以通过在配置中指定 scope 属性，将 Bean 改为多例（Prototype）模式，这样每次获取的都是新的实例。</p>
<pre><code class="language-java">@Bean
@Scope("prototype")  // 每次获取都是新的实例
public MyBean myBean() {
    return new MyBean();
}
</code></pre>
<p>除了单例和多例，Spring 还支持其他作用域，如请求作用域（Request）、会话作用域（Session）等，适合 Web 应用中特定的使用场景。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-08a9cb31-5a4f-4224-94cd-0c0f643a57ea.png" alt="三分恶面渣逆袭：Spring Bean支持作用域" /></p>
<ul>
<li><strong>request</strong>：每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP Request 内有效。</li>
<li><strong>session</strong>：同一个 Session 共享一个 Bean，不同的 Session 使用不同的 Bean。</li>
<li><strong>globalSession</strong>：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经移除。</li>
</ul>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的同学 1 贝壳找房后端技术一面面试原题：bean是单例还是多例的，具体怎么修改</li>
</ol>
</blockquote>
<h3 id="14spring-中的单例-bean-会存在线程安全问题吗"><a class="header" href="#14spring-中的单例-bean-会存在线程安全问题吗">14.Spring 中的单例 Bean 会存在线程安全问题吗？</a></h3>
<p>Spring Bean 的默认作用域是单例（Singleton），这意味着 Spring 容器中只会存在一个 Bean 实例，并且该实例会被多个线程共享。</p>
<p>如果单例 Bean 是无状态的，也就是没有成员变量，那么这个单例 Bean 是线程安全的。比如 Spring MVC 中的 Controller、Service、Dao 等，基本上都是无状态的。</p>
<p>但如果 Bean 的内部状态是可变的，且没有进行适当的同步处理，就可能出现线程安全问题。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-35dacef4-1a9e-45e1-b3f2-5a91227eb244.png" alt="三分恶面渣逆袭：Spring单例Bean线程安全问题" /></p>
<h4 id="单例-bean-线程安全问题怎么解决呢"><a class="header" href="#单例-bean-线程安全问题怎么解决呢">单例 Bean 线程安全问题怎么解决呢？</a></h4>
<p>第一，使用局部变量。局部变量是线程安全的，因为每个线程都有自己的局部变量副本。尽量使用局部变量而不是共享的成员变量。</p>
<pre><code class="language-java">public class MyService {
    public void process() {
        int localVar = 0;
        // 使用局部变量进行操作
    }
}
</code></pre>
<p>第二，尽量使用无状态的 Bean，即不在 Bean 中保存任何可变的状态信息。</p>
<pre><code class="language-java">public class MyStatelessService {
    public void process() {
        // 无状态处理
    }
}
</code></pre>
<p>第三，同步访问。如果 Bean 中确实需要保存可变状态，可以通过 <a href="https://javabetter.cn/thread/synchronized-1.html">synchronized 关键字</a>或者 <a href="https://javabetter.cn/thread/reentrantLock.html">Lock 接口</a>来保证线程安全。</p>
<pre><code class="language-java">public class MyService {
    private int sharedVar;

    public synchronized void increment() {
        sharedVar++;
    }
}
</code></pre>
<p>或者将 Bean 中的成员变量保存到 ThreadLocal 中，<a href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 可以保证多线程环境下变量的隔离。</p>
<pre><code class="language-java">public class MyService {
    private ThreadLocal&lt;Integer&gt; localVar = ThreadLocal.withInitial(() -&gt; 0);

    public void process() {
        localVar.set(localVar.get() + 1);
    }
}
</code></pre>
<p>再或者使用线程安全的工具类，比如说 <a href="https://javabetter.cn/thread/atomic.html">AtomicInteger</a>、<a href="https://javabetter.cn/thread/ConcurrentHashMap.html">ConcurrentHashMap</a>、<a href="https://javabetter.cn/thread/CopyOnWriteArrayList.html">CopyOnWriteArrayList</a> 等。</p>
<pre><code class="language-java">public class MyService {
    private ConcurrentHashMap&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();

    public void putValue(String key, String value) {
        map.put(key, value);
    }
}
</code></pre>
<p>第四，将 Bean 定义为原型作用域（Prototype）。原型作用域的 Bean 每次请求都会创建一个新的实例，因此不存在线程安全问题。</p>
<pre><code class="language-java">@Component
@Scope("prototype")
public class MyService {
    // 实例变量
}
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里面经同学 1 闲鱼后端一面的原题：spring的bean的并发安全问题</li>
</ol>
</blockquote>
<h3 id="15说说循环依赖"><a class="header" href="#15说说循环依赖">15.说说循环依赖?</a></h3>
<p>A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-f8fea53f-56fa-4cca-9199-ec7f648da625.png" alt="三分恶面渣逆袭：Spring循环依赖" /></p>
<blockquote>
<p>循环依赖只发生在 Singleton 作用域的 Bean 之间，因为如果是 Prototype 作用域的 Bean，Spring 会直接抛出异常。</p>
</blockquote>
<p>原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃。。。。</p>
<p>我们来看一个实例，先是 PrototypeBeanA：</p>
<pre><code class="language-java">@Component
@Scope("prototype")
public class PrototypeBeanA {
    private final PrototypeBeanB prototypeBeanB;

    @Autowired
    public PrototypeBeanA(PrototypeBeanB prototypeBeanB) {
        this.prototypeBeanB = prototypeBeanB;
    }
}
</code></pre>
<p>然后是 PrototypeBeanB：</p>
<pre><code class="language-java">@Component
@Scope("prototype")
public class PrototypeBeanB {
    private final PrototypeBeanA prototypeBeanA;

    @Autowired
    public PrototypeBeanB(PrototypeBeanA prototypeBeanA) {
        this.prototypeBeanA = prototypeBeanA;
    }
}
</code></pre>
<p>再然后是测试：</p>
<pre><code class="language-java">@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Bean
    CommandLineRunner commandLineRunner(ApplicationContext ctx) {
        return args -&gt; {
            // 尝试获取PrototypeBeanA的实例
            PrototypeBeanA beanA = ctx.getBean(PrototypeBeanA.class);
        };
    }
}
</code></pre>
<p>运行结果：</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240310202703.png" alt="二哥的 Java 进阶之路：循环依赖" /></p>
<p>在这个示例中，当 Spring 应用启动并尝试获取 PrototypeBeanA 或 PrototypeBeanB 的实例时，将会遇到问题。因为它们互相依赖，而 Spring 无法解决 Prototype 作用域 bean 的循环依赖问题。</p>
<h4 id="spring-可以解决哪些情况的循环依赖"><a class="header" href="#spring-可以解决哪些情况的循环依赖">Spring 可以解决哪些情况的循环依赖？</a></h4>
<p>看看这几种情形（AB 循环依赖）：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-37bb576d-b4af-42ed-91f4-d846ceb012b6.png" alt="三分恶面渣逆袭：循环依赖的几种情形" /></p>
<p>也就是说：</p>
<ul>
<li>AB 均采用构造器注入，不支持</li>
<li>AB 均采用 setter 注入，支持</li>
<li>AB 均采用属性自动注入，支持</li>
<li>A 中注入的 B 为 setter 注入，B 中注入的 A 为构造器注入，支持</li>
<li>B 中注入的 A 为 setter 注入，A 中注入的 B 为构造器注入，不支持</li>
</ul>
<p>第四种可以，第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p>
<p>简单总结下，当循环依赖的实例都采用 setter 方法注入时，Spring 支持，都采用构造器注入的时候，不支持；构造器注入和 setter 注入同时存在的时候，看天（😂）。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：如何解决循环依赖？</li>
</ol>
</blockquote>
<h3 id="16spring-怎么解决循环依赖呢"><a class="header" href="#16spring-怎么解决循环依赖呢">16.Spring 怎么解决循环依赖呢？</a></h3>
<p>Spring 通过三级缓存机制来解决循环依赖：</p>
<ol>
<li>一级缓存：存放完全初始化好的单例 Bean。</li>
<li>二级缓存：存放正在创建但未完全初始化的 Bean 实例。</li>
<li>三级缓存：存放 Bean 工厂对象，用于提前暴露 Bean。</li>
</ol>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-01d92863-a2cb-4f61-8d8d-30ecf0279b28.png" alt="三分恶面渣逆袭：三级缓存" /></p>
<h4 id="三级缓存解决循环依赖的过程是什么样的"><a class="header" href="#三级缓存解决循环依赖的过程是什么样的">三级缓存解决循环依赖的过程是什么样的？</a></h4>
<ol>
<li>实例化 Bean 时，将其早期引用放入三级缓存。</li>
<li>其他依赖该 Bean 的对象，可以从缓存中获取其引用。</li>
<li>初始化完成后，将 Bean 移入一级缓存。</li>
</ol>
<p>假如 A、B 两个类发生循环依赖：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-cfc09f84-f8e1-4702-80b6-d115843e81fe.png" alt="三分恶面渣逆袭：循环依赖" /></p>
<p>A 实例的初始化过程：</p>
<p>①、创建 A 实例，实例化的时候把 A 的对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然这个对象还不完整，但是先曝光出来让大家知道。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-1a8bdc29-ff43-4ff4-9b61-3eedd9da59b3.png" alt="三分恶面渣逆袭：A 对象工厂" /></p>
<p>②、A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B。</p>
<p>③、同样，B 注⼊属性时发现依赖 A，它就从缓存里找 A 对象。依次从⼀级到三级缓存查询 A。</p>
<p>发现可以从三级缓存中通过对象⼯⼚拿到 A，虽然 A 不太完善，但是存在，就把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成了，把 B 放入⼀级缓存。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-bf2507bf-96aa-4b88-a58b-7ec41d11bc70.png" alt="三分恶面渣逆袭：放入一级缓存" /></p>
<p>④、接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</p>
<p>⑤、最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-022f7cb9-2c83-4fe9-b252-b02bd0fb2435.png" alt="三分恶面渣逆袭：AB 都好了" /></p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：如何解决循环依赖？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：Spring如何解决循环依赖？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 9 面试题目原题：Spring源码看过吗？Spring的三级缓存知道吗？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：spring三级缓存解决循环依赖问题</li>
</ol>
</blockquote>
<h3 id="17为什么要三级缓存级不吗"><a class="header" href="#17为什么要三级缓存级不吗">17.为什么要三级缓存？⼆级不⾏吗？</a></h3>
<p>不行，主要是为了 <strong>⽣成代理对象</strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。</p>
<p>因为三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。</p>
<p>假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-6ece8a46-25b1-459b-8cfa-19fc696dd7d6.png" alt="三分恶面渣逆袭：二级缓存不行的原因" /></p>
<h4 id="如果缺少第二级缓存会有什么问题"><a class="header" href="#如果缺少第二级缓存会有什么问题">如果缺少第二级缓存会有什么问题？</a></h4>
<p>如果没有二级缓存，Spring 无法在未完成初始化的情况下暴露 Bean。会导致代理 Bean 的循环依赖问题，因为某些代理逻辑无法在三级缓存中提前暴露。最终可能抛出 BeanCurrentlyInCreationException。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：循环依赖有了解过吗？出现循环依赖的原因？三大缓存存储内容的区别？如何解决循环依赖？如果缺少第二级缓存会有什么问题？</li>
</ol>
</blockquote>
<h3 id="18autowired-的实现原理"><a class="header" href="#18autowired-的实现原理">18.@Autowired 的实现原理？</a></h3>
<p>实现@Autowired 的关键是：<strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>在 Bean 的初始化阶段，会通过 Bean 后置处理器来进行一些前置和后置的处理。</p>
<p>实现@Autowired 的功能，也是通过后置处理器来完成的。这个后置处理器就是 AutowiredAnnotationBeanPostProcessor。</p>
<ul>
<li>
<p>Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。</p>
</li>
<li>
<p>在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues()方法，在该方法中就会进行@Autowired 注解的解析，然后实现自动装配。</p>
</li>
</ul>
<pre><code class="language-java">/**
* 属性赋值
**/
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
          //…………
          if (hasInstAwareBpps) {
              if (pvs == null) {
                  pvs = mbd.getPropertyValues();
              }

              PropertyValues pvsToUse;
              for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
                  InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
                  if (pvsToUse == null) {
                      if (filteredPds == null) {
                          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                      }
                      //执行后处理器，填充属性，完成自动装配
                      //调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法
                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
                      if (pvsToUse == null) {
                          return;
                      }
                  }
              }
          }
         //…………
  }
</code></pre>
<ul>
<li>postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。</li>
</ul>
<pre><code class="language-java">  public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
      //@Autowired注解、@Inject和@Value注解的属性和方法
      InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);

      try {
          //属性填充
          metadata.inject(bean, beanName, pvs);
          return pvs;
      } catch (BeanCreationException var6) {
          throw var6;
      } catch (Throwable var7) {
          throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", var7);
      }
  }
</code></pre>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="aop"><a class="header" href="#aop">AOP</a></h2>
<h3 id="19说说什么是-aop"><a class="header" href="#19说说什么是-aop">19.说说什么是 AOP？</a></h3>
<p>AOP，也就是面向切面编程，简单点说，AOP 就是把一些业务逻辑中的相同代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-09dbcda4-7c1b-42d6-8520-1a5fc84abbde.png" alt="三分恶面渣逆袭：横向抽取" /></p>
<p>举个例子，假如我们现在需要在业务代码开始前进行参数校验，在结束后打印日志，该怎么办呢？</p>
<p>我们可以把<code>日志记录</code>和<code>数据校验</code>这两个功能抽取出来，形成一个切面，然后在业务代码中引入这个切面，这样就可以实现业务逻辑和通用逻辑的分离。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-4754b4c0-0356-4077-a2f9-55e246cf8ba0.png" alt="三分恶面渣逆袭：AOP应用示例" /></p>
<p>业务代码不再关心这些通用逻辑，只需要关心自己的业务实现，这样就实现了业务逻辑和通用逻辑的分离。</p>
<h4 id="aop-有哪些核心概念"><a class="header" href="#aop-有哪些核心概念">AOP 有哪些核心概念？</a></h4>
<ul>
<li><strong>切面</strong>（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</li>
<li><strong>连接点</strong>（Join Point）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中，连接点指的是被拦截到的方法，实际上连接点还可以是字段或者构造方法</li>
<li><strong>切点</strong>（Pointcut）：对连接点进行拦截的定位</li>
<li><strong>通知</strong>（Advice）：指拦截到连接点之后要执行的代码，也可以称作<strong>增强</strong></li>
<li><strong>目标对象</strong> （Target）：代理的目标对象</li>
<li><strong>引介</strong>（introduction）：一种特殊的增强，可以动态地为类添加一些属性和方法</li>
<li><strong>织入</strong>（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</li>
</ul>
<h4 id="织入有哪几种方式"><a class="header" href="#织入有哪几种方式">织入有哪几种方式？</a></h4>
<p>①、编译期织入：切面在目标类编译时被织入。</p>
<p>②、类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p>
<p>③、运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。</p>
<p>Spring AOP 采用运行期织入，而 AspectJ 可以在编译期织入和类加载时织入。</p>
<h4 id="aspectj-是什么"><a class="header" href="#aspectj-是什么">AspectJ 是什么？</a></h4>
<p>AspectJ 是一个 AOP 框架，它可以做很多 Spring AOP 干不了的事情，比如说支持编译时、编译后和类加载时织入切面。并且提供更复杂的切点表达式和通知类型。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240806100537.png" alt="AspectJ 官网" /></p>
<p>下面是一个简单的 AspectJ 示例：</p>
<pre><code class="language-java">// 定义一个切面
@Aspect
public class LoggingAspect {

    // 定义一个切点，匹配 com.example 包下的所有方法
    @Pointcut("execution(* com.example..*(..))")
    private void selectAll() {}

    // 定义一个前置通知，在匹配的方法执行之前执行
    @Before("selectAll()")
    public void beforeAdvice() {
        System.out.println("A method is about to be executed.");
    }
}
</code></pre>
<h4 id="aop-有哪些环绕方式"><a class="header" href="#aop-有哪些环绕方式">AOP 有哪些环绕方式？</a></h4>
<p>AOP 一般有 <strong>5 种</strong>环绕方式：</p>
<ul>
<li>前置通知 (@Before)</li>
<li>返回通知 (@AfterReturning)</li>
<li>异常通知 (@AfterThrowing)</li>
<li>后置通知 (@After)</li>
<li>环绕通知 (@Around)</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-320fa34f-6620-419c-b17a-4f516a83caeb.png" alt="三分恶面渣逆袭：环绕方式" /></p>
<p>多个切面的情况下，可以通过 <code>@Order</code> 指定先后顺序，数字越小，优先级越高。代码示例如下：</p>
<pre><code class="language-java">@Aspect
@Component
public class WebLogAspect {

    private final static Logger logger = LoggerFactory.getLogger(WebLogAspect.class);

    @Pointcut("@annotation(cn.fighter3.spring.aop_demo.WebLog)")
    public void webLog() {}

    @Before("webLog()")
    public void doBefore(JoinPoint joinPoint) throws Throwable {
        // 开始打印请求日志
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        // 打印请求相关参数
        logger.info("========================================== Start ==========================================");
        // 打印请求 url
        logger.info("URL            : {}", request.getRequestURL().toString());
        // 打印 Http method
        logger.info("HTTP Method    : {}", request.getMethod());
        // 打印调用 controller 的全路径以及执行方法
        logger.info("Class Method   : {}.{}", joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());
        // 打印请求的 IP
        logger.info("IP             : {}", request.getRemoteAddr());
        // 打印请求入参
        logger.info("Request Args   : {}",new ObjectMapper().writeValueAsString(joinPoint.getArgs()));
    }

    @After("webLog()")
    public void doAfter() throws Throwable {
        // 结束后打个分隔线，方便查看
        logger.info("=========================================== End ===========================================");
    }

    @Around("webLog()")
    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        //开始时间
        long startTime = System.currentTimeMillis();
        Object result = proceedingJoinPoint.proceed();
        // 打印出参
        logger.info("Response Args  : {}", new ObjectMapper().writeValueAsString(result));
        // 执行耗时
        logger.info("Time-Consuming : {} ms", System.currentTimeMillis() - startTime);
        return result;
    }
}
</code></pre>
<h4 id="spring-aop-发生在什么时候"><a class="header" href="#spring-aop-发生在什么时候">Spring AOP 发生在什么时候？</a></h4>
<p>Spring AOP 基于运行时代理机制，这意味着 Spring AOP 是在运行时通过动态代理生成的，而不是在编译时或类加载时生成的。</p>
<p>在 Spring 容器初始化 Bean 的过程中，Spring AOP 会检查 Bean 是否需要应用切面。如果需要，Spring 会为该 Bean 创建一个代理对象，并在代理对象中织入切面逻辑。这一过程发生在 Spring 容器的后处理器（BeanPostProcessor）阶段。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240806102547.png" alt="二哥的 Java 进阶之路：BeanPostProcessor" /></p>
<h4 id="简单总结一下-aop"><a class="header" href="#简单总结一下-aop">简单总结一下 AOP</a></h4>
<p>AOP，也就是面向切面编程，是一种编程范式，旨在提高代码的模块化。比如说可以将日志记录、事务管理等分离出来，来提高代码的可重用性。</p>
<p>AOP 的核心概念包括切面（Aspect）、连接点（Join Point）、通知（Advice）、切点（Pointcut）和织入（Weaving）等。</p>
<p>① 像日志打印、事务管理等都可以抽离为切面，可以声明在类的方法上。像 <code>@Transactional</code> 注解，就是一个典型的 AOP 应用，它就是通过 AOP 来实现事务管理的。我们只需要在方法上添加 <code>@Transactional</code> 注解，Spring 就会在方法执行前后添加事务管理的逻辑。</p>
<p>② Spring AOP 是基于代理的，它默认使用 JDK 动态代理和 CGLIB 代理来实现 AOP。</p>
<p>③ Spring AOP 的织入方式是运行时织入，而 AspectJ 支持编译时织入、类加载时织入。</p>
<h4 id="aop和-oop-的关系"><a class="header" href="#aop和-oop-的关系">AOP和 OOP 的关系？</a></h4>
<p>AOP 和 OOP 是互补的编程思想：</p>
<ol>
<li>OOP 通过类和对象封装数据和行为，专注于核心业务逻辑。</li>
<li>AOP 提供了解决横切关注点（如日志、权限、事务等）的机制，将这些逻辑集中管理。</li>
</ol>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯 Java 后端实习一面原题：说说 AOP 的原理。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米 25 届日常实习一面原题：说说你对 AOP 和 IoC 的理解。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 Spring AOP 的实现原理</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经合集同学 1 Java 后端面试原题：介绍 Spring IoC 和 AOP?</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的招商银行面经同学 6 招银网络科技面试原题：SpringBoot框架的AOP、IOC/DI？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 4 一面面试原题：Spring AOP发生在什么时候</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：Spring AOP的概念了解吗？AOP和 OOP 的关系？</li>
</ol>
</blockquote>
<h3 id="20aop的使用场景有哪些"><a class="header" href="#20aop的使用场景有哪些">20.AOP的使用场景有哪些？</a></h3>
<p>AOP 的使用场景有很多，比如说日志记录、事务管理、权限控制、性能监控等。</p>
<p>我们在<a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中主要利用 AOP 来打印接口的入参和出参日志、执行时间，方便后期 bug 溯源和性能调优。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240310180334.png" alt="沉默王二：技术派教程" /></p>
<p>第一步，自定义注解作为切点</p>
<pre><code class="language-java">@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MdcDot {
    String bizCode() default "";
}
</code></pre>
<p>第二步，配置 AOP 切面：</p>
<ul>
<li><code>@Aspect</code>：标识切面</li>
<li><code>@Pointcut</code>：设置切点，这里以自定义注解为切点</li>
<li><code>@Around</code>：环绕切点，打印方法签名和执行时间</li>
</ul>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240310180741.png" alt="技术派项目：配置 AOP 切面" /></p>
<p>第三步，在使用的地方加上自定义注解</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240310181233.png" alt="技术派项目：使用注解" /></p>
<p>第四步，当接口被调用时，就可以看到对应的执行日志。</p>
<pre><code>2023-06-16 11:06:13,008 [http-nio-8080-exec-3] INFO |00000000.1686884772947.468581113|101|c.g.p.forum.core.mdc.MdcAspect.handle(MdcAspect.java:47) - 方法执行耗时: com.github.paicoding.forum.web.front.article.rest.ArticleRestController#recommend = 47
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：AOP应用场景</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：AOP的使用场景有哪些？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 9 面试原题：项目中的AOP是怎么用到的</li>
</ol>
</blockquote>
<h3 id="21说说-jdk-动态代理和-cglib-代理"><a class="header" href="#21说说-jdk-动态代理和-cglib-代理">21.说说 JDK 动态代理和 CGLIB 代理？</a></h3>
<p>AOP 是通过<a href="https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg">动态代理</a>实现的，代理方式有两种：JDK 动态代理和 CGLIB 代理。</p>
<p>①、JDK 动态代理是基于接口的代理，只能代理实现了接口的类。</p>
<p>使用 JDK 动态代理时，Spring AOP 会创建一个代理对象，该代理对象实现了目标对象所实现的接口，并在方法调用前后插入横切逻辑。</p>
<p>优点：只需依赖 JDK 自带的 <code>java.lang.reflect.Proxy</code> 类，不需要额外的库；缺点：只能代理接口，不能代理类本身。</p>
<p>示例代码：</p>
<pre><code class="language-java">public interface Service {
    void perform();
}

public class ServiceImpl implements Service {
    public void perform() {
        System.out.println("Performing service...");
    }
}

public class ServiceInvocationHandler implements InvocationHandler {
    private Object target;

    public ServiceInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before method");
        Object result = method.invoke(target, args);
        System.out.println("After method");
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        Service service = new ServiceImpl();
        Service proxy = (Service) Proxy.newProxyInstance(
            service.getClass().getClassLoader(),
            service.getClass().getInterfaces(),
            new ServiceInvocationHandler(service)
        );
        proxy.perform();
    }
}
</code></pre>
<p>②、CGLIB 动态代理是基于继承的代理，可以代理没有实现接口的类。</p>
<p>使用 CGLIB 动态代理时，Spring AOP 会生成目标类的子类，并在方法调用前后插入横切逻辑。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240321105653.png" alt="图片来源于网络" /></p>
<p>优点：可以代理没有实现接口的类，灵活性更高；缺点：需要依赖 CGLIB 库，创建代理对象的开销相对较大。</p>
<p>示例代码：</p>
<pre><code class="language-java">public class Service {
    public void perform() {
        System.out.println("Performing service...");
    }
}

public class ServiceInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Before method");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("After method");
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Service.class);
        enhancer.setCallback(new ServiceInterceptor());

        Service proxy = (Service) enhancer.create();
        proxy.perform();
    }
}
</code></pre>
<h4 id="选择-cglib-还是-jdk-动态代理"><a class="header" href="#选择-cglib-还是-jdk-动态代理">选择 CGLIB 还是 JDK 动态代理？</a></h4>
<ul>
<li>如果目标对象没有实现任何接口，则只能使用 CGLIB 代理。如果目标对象实现了接口，通常首选 JDK 动态代理。</li>
<li>虽然 CGLIB 在代理类的生成过程中可能消耗更多资源，但在运行时具有较高的性能。对于性能敏感且代理对象创建频率不高的场景，可以考虑使用 CGLIB。</li>
<li>JDK 动态代理是 Java 原生支持的，不需要额外引入库。而 CGLIB 需要将 CGLIB 库作为依赖加入项目中。</li>
</ul>
<h4 id="你会用-jdk-动态代理和-cglib-吗"><a class="header" href="#你会用-jdk-动态代理和-cglib-吗">你会用 JDK 动态代理和 CGLIB 吗？</a></h4>
<p>假设我们有这样一个小场景，客服中转，解决用户问题：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-c5c4b247-62dd-43a2-a043-da51c58f77c8.png" alt="三分恶面渣逆袭：用户向客服提问题" /></p>
<p>①、JDK 动态代理实现：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-65b14a3f-2653-463e-af77-a8875d3d635c.png" alt="三分恶面渣逆袭：JDK动态代理类图" /></p>
<p>第一步，创建接口</p>
<pre><code class="language-java">public interface ISolver {
    void solve();
}
</code></pre>
<p>第二步，实现对应接口</p>
<pre><code class="language-java">public class Solver implements ISolver {
    @Override
    public void solve() {
        System.out.println("疯狂掉头发解决问题……");
    }
}
</code></pre>
<p>第三步，动态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理，这里用了一个匿名内部类方式重写 InvocationHandler 方法。</p>
<pre><code class="language-java">public class ProxyFactory {

    // 维护一个目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 为目标对象生成代理对象
    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("请问有什么可以帮到您？");

                        // 调用目标对象方法
                        Object returnValue = method.invoke(target, args);

                        System.out.println("问题已经解决啦！");
                        return null;
                    }
                });
    }
}
</code></pre>
<p>第五步，客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        //目标对象:程序员
        ISolver developer = new Solver();
        //代理：客服小姐姐
        ISolver csProxy = (ISolver) new ProxyFactory(developer).getProxyInstance();
        //目标方法：解决问题
        csProxy.solve();
    }
}
</code></pre>
<p>②、CGLIB 动态代理实现：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-74da87af-20d1-4a5b-a212-3837a15f0bab.png" alt="三分恶面渣逆袭：CGLIB动态代理类图" /></p>
<p>第一步：定义目标类（Solver），目标类 Solver 定义了一个 solve 方法，模拟了解决问题的行为。目标类不需要实现任何接口，这与 JDK 动态代理的要求不同。</p>
<pre><code class="language-java">public class Solver {

    public void solve() {
        System.out.println("疯狂掉头发解决问题……");
    }
}
</code></pre>
<p>第二步：动态代理工厂（ProxyFactory），ProxyFactory 类实现了 MethodInterceptor 接口，这是 CGLIB 提供的一个方法拦截接口，用于定义方法的拦截逻辑。</p>
<pre><code class="language-java">public class ProxyFactory implements MethodInterceptor {

    //维护一个目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    //为目标对象生成代理对象
    public Object getProxyInstance() {
        //工具类
        Enhancer en = new Enhancer();
        //设置父类
        en.setSuperclass(target.getClass());
        //设置回调函数
        en.setCallback(this);
        //创建子类对象代理
        return en.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("请问有什么可以帮到您？");
        // 执行目标对象的方法
        Object returnValue = method.invoke(target, args);
        System.out.println("问题已经解决啦！");
        return null;
    }

}
</code></pre>
<ul>
<li>ProxyFactory 接收一个 Object 类型的 target，即目标对象的实例。</li>
<li>使用 CGLIB 的 Enhancer 类来生成目标类的子类（代理对象）。通过 setSuperclass 设置代理对象的父类为目标对象的类，setCallback 设置方法拦截器为当前对象（this），最后调用 create 方法生成并返回代理对象。</li>
<li>重写 MethodInterceptor 接口的 intercept 方法以提供方法拦截逻辑。在目标方法执行前后添加自定义逻辑，然后通过 method.invoke 调用目标对象的方法。</li>
</ul>
<p>第三步：客户端使用代理，首先创建目标对象（Solver 的实例），然后使用 ProxyFactory 创建该目标对象的代理。通过代理对象调用 solve 方法时，会先执行 intercept 方法中定义的逻辑，然后执行目标方法，最后再执行 intercept 方法中的后续逻辑。</p>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        //目标对象:程序员
        Solver developer = new Solver();
        //代理：客服小姐姐
        Solver csProxy = (Solver) new ProxyFactory(developer).getProxyInstance();
        //目标方法：解决问题
        csProxy.solve();
    }
}
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的帆软同学 3 Java 后端一面的原题：cglib 的原理</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Spring AOP 实现原理</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米面经同学 F 面试原题：两种动态代理的区别</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 8 Java 后端实习一面面试原题：spring的aop是如何实现的</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯云智面经同学 20 二面面试原题：spring aop的底层原理是什么？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团面经同学 3 Java 后端技术一面面试原题：java的反射机制，反射的应用场景AOP的实现原理是什么，与动态代理和反射有什么区别</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 12 Java 技术面试原题：代理介绍一下，jdk和cglib的区别</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：Spring AOP的实现原理？JDK动态代理和CGLib动态代理的各自实现及其区别？现在需要统计方法的具体执行时间，说下如何使用AOP来实现？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的理想汽车面经同学 2 一面面试原题：了解AOP底层是怎么做的吗？</li>
</ol>
</blockquote>
<h3 id="22说说-spring-aop-和-aspectj-aop-区别"><a class="header" href="#22说说-spring-aop-和-aspectj-aop-区别">22.说说 Spring AOP 和 AspectJ AOP 区别?</a></h3>
<p>Spring AOP 属于<code>运行时增强</code>，主要具有如下特点：</p>
<ol>
<li>
<p>基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</p>
</li>
<li>
<p>Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</p>
</li>
<li>
<p>在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</p>
</li>
<li>
<p>Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p>
</li>
</ol>
<p>AspectJ 是一个易用的功能强大的 AOP 框架，属于<code>编译时增强</code>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p>
<p>AspectJ 属于<strong>静态织入</strong>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p>
<ol>
<li>
<p>编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p>
</li>
<li>
<p>编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p>
</li>
<li>
<p>类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p>
</li>
</ol>
<p>整体对比如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-d1dbe9d9-c55f-4293-8622-d9759064d613.png" alt="Spring AOP和AspectJ对比" /></p>
<h3 id="40说说-aop-和反射的区别补充"><a class="header" href="#40说说-aop-和反射的区别补充">40.说说 AOP 和反射的区别？（补充）</a></h3>
<blockquote>
<p>2024 年 7 月 27 日增补。</p>
</blockquote>
<ol>
<li>反射：用于检查和操作类的方法和字段，动态调用方法或访问字段。反射是 Java 提供的内置机制，直接操作类对象。</li>
<li>动态代理：通过生成代理类来拦截方法调用，通常用于 AOP 实现。动态代理使用反射来调用被代理的方法。</li>
</ol>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的得物面经同学 9 面试题目原题：抛开Spring，讲讲反射和动态代理？那三种代理模式怎么实现的？</li>
</ol>
</blockquote>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="事务"><a class="header" href="#事务">事务</a></h2>
<p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>
<h3 id="23spring-事务的种类"><a class="header" href="#23spring-事务的种类">23.Spring 事务的种类？</a></h3>
<p>在 Spring 中，事务管理可以分为两大类：声明式事务管理和编程式事务管理。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-d3ee77fa-926d-4c39-91f8-a8b1544a9134.png" alt="三分恶面渣逆袭：Spring事务分类" /></p>
<h4 id="介绍一下编程式事务管理"><a class="header" href="#介绍一下编程式事务管理">介绍一下编程式事务管理？</a></h4>
<p>编程式事务可以使用 TransactionTemplate 和 PlatformTransactionManager 来实现，需要显式执行事务。允许我们在代码中直接控制事务的边界，通过编程方式明确指定事务的开始、提交和回滚。</p>
<pre><code class="language-java">public class AccountService {
    private TransactionTemplate transactionTemplate;

    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }

    public void transfer(final String out, final String in, final Double money) {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // 转出
                accountDao.outMoney(out, money);
                // 转入
                accountDao.inMoney(in, money);
            }
        });
    }
}
</code></pre>
<p>在上面的代码中，我们使用了 TransactionTemplate 来实现编程式事务，通过 execute 方法来执行事务，这样就可以在方法内部实现事务的控制。</p>
<h4 id="介绍一下声明式事务管理"><a class="header" href="#介绍一下声明式事务管理">介绍一下声明式事务管理？</a></h4>
<p>声明式事务是建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在目标方法执行完之后根据执行情况提交或者回滚事务。</p>
<p>相比较编程式事务，优点是不需要在业务逻辑代码中掺杂事务管理的代码，Spring 推荐通过 @Transactional 注解的方式来实现声明式事务管理，也是日常开发中最常用的。</p>
<p>不足的地方是，声明式事务管理最细粒度只能作用到方法级别，无法像编程式事务那样可以作用到代码块级别。</p>
<pre><code class="language-java">@Service
public class AccountService {
    @Autowired
    private AccountDao accountDao;

    @Transactional
    public void transfer(String out, String in, Double money) {
        // 转出
        accountDao.outMoney(out, money);
        // 转入
        accountDao.inMoney(in, money);
    }
}
</code></pre>
<h4 id="说说两者的区别"><a class="header" href="#说说两者的区别">说说两者的区别？</a></h4>
<ul>
<li><strong>编程式事务管理</strong>：需要在代码中显式调用事务管理的 API 来控制事务的边界，比较灵活，但是代码侵入性较强，不够优雅。</li>
<li><strong>声明式事务管理</strong>：这种方式使用 Spring 的 AOP 来声明事务，将事务管理代码从业务代码中分离出来。优点是代码简洁，易于维护。但缺点是不够灵活，只能在预定义的方法上使用事务。</li>
</ul>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东同学 10 后端实习一面的原题：Spring 事务怎么实现的</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的农业银行面经同学 7 Java 后端面试原题：Spring 如何保证事务</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 12 Java 技术面试原题：Spring的事务用过吗，在项目里面怎么使用的</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的虾皮面经同学 13 一面面试原题：spring事务</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：如何使用spring实现事务</li>
</ol>
</blockquote>
<h3 id="24说说-spring-的事务隔离级别"><a class="header" href="#24说说-spring-的事务隔离级别">24.说说 Spring 的事务隔离级别？</a></h3>
<p>好，事务的隔离级别定义了一个事务可能受其他并发事务影响的程度。SQL 标准定义了四个隔离级别，Spring 都支持，并且提供了对应的机制来配置它们，定义在 TransactionDefinition 接口中。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240326082116.png" alt="二哥的 Java 进阶之路" /></p>
<p>①、ISOLATION_DEFAULT：使用数据库默认的隔离级别（你们爱咋咋滴 😁），MySQL 默认的是可重复读，Oracle 默认的读已提交。</p>
<p>②、ISOLATION_READ_UNCOMMITTED：读未提交，允许事务读取未被其他事务提交的更改。这是隔离级别最低的设置，可能会导致“脏读”问题。</p>
<p>③、ISOLATION_READ_COMMITTED：读已提交，确保事务只能读取已经被其他事务提交的更改。这可以防止“脏读”，但仍然可能发生“不可重复读”和“幻读”问题。</p>
<p>④、ISOLATION_REPEATABLE_READ：可重复读，确保事务可以多次从一个字段中读取相同的值，即在这个事务内，其他事务无法更改这个字段，从而避免了“不可重复读”，但仍可能发生“幻读”问题。</p>
<p>⑤、ISOLATION_SERIALIZABLE：串行化，这是最高的隔离级别，它完全隔离了事务，确保事务序列化执行，以此来避免“脏读”、“不可重复读”和“幻读”问题，但性能影响也最大。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：Spring 中的事务的隔离级别，事务的传播行为？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米面经同学 E 第二个部门 Java 后端技术一面面试原题：spring 的隔离机制，默认是哪一种</li>
</ol>
</blockquote>
<h3 id="25spring-的事务传播机制"><a class="header" href="#25spring-的事务传播机制">25.Spring 的事务传播机制？</a></h3>
<p>事务的传播机制定义了方法在被另一个事务方法调用时的事务行为，这些行为定义了事务的边界和事务上下文如何在方法调用链中传播。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-a6e2a8dc-9771-4d8b-9d91-76ddee98af1a.png" alt="三分恶面渣逆袭：6种事务传播机制" /></p>
<p>Spring 的默认传播行为是 PROPAGATION_REQUIRED，即如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p>事务传播机制是使用 <a href="https://javabetter.cn/thread/ThreadLocal.html">ThreadLocal</a> 实现的，所以，如果调用的方法是在新线程中，事务传播会失效。</p>
<pre><code class="language-java">@Transactional
public void parentMethod() {
    new Thread(() -&gt; childMethod()).start();
}

public void childMethod() {
    // 这里的操作将不会在 parentMethod 的事务范围内执行
}
</code></pre>
<p>Spring 默认的事务传播行为是 PROPAFATION_REQUIRED，即如果多个 <code>ServiceX#methodX()</code> 都工作在事务环境下，且程序中存在这样的调用链 <code>Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()</code>，那么这 3 个服务类的 3 个方法都通过 Spring 的事务传播机制工作在同一个事务中。</p>
<h4 id="protected-和-private-加事务会生效吗"><a class="header" href="#protected-和-private-加事务会生效吗">protected 和 private 加事务会生效吗</a></h4>
<p>在 Spring 中，<strong>只有通过 Spring 容器的 AOP 代理调用的公开方法（public method）上的<code>@Transactional</code>注解才会生效</strong>。</p>
<p>如果在 protected、private 方法上使用<code>@Transactional</code>，这些事务注解将不会生效，原因：Spring 默认使用基于 JDK 的动态代理（当接口存在时）或基于 CGLIB 的代理（当只有类时）来实现事务。这两种代理机制都只能代理公开的方法。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东同学 10 后端实习一面的原题：事务的传播机制</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米春招同学 K 一面面试原题：事务传播，protected 和 private 加事务会生效吗,还有那些不生效的情况</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为面经同学 8 技术二面面试原题：Spring 中的事务的隔离级别，事务的传播行为？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的oppo 面经同学 8 后端开发秋招一面面试原题：讲一下Spring事务传播机制</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：介绍事务传播模型</li>
</ol>
</blockquote>
<h3 id="26声明式事务实现原理了解吗"><a class="header" href="#26声明式事务实现原理了解吗">26.声明式事务实现原理了解吗？</a></h3>
<p>Spring 的声明式事务管理是通过 AOP（面向切面编程）和代理机制实现的。</p>
<p>第一步，<strong>在 Bean 初始化阶段创建代理对象</strong>：</p>
<p>Spring 容器在初始化单例 Bean 的时候，会遍历所有的 BeanPostProcessor 实现类，并执行其 postProcessAfterInitialization 方法。</p>
<p>在执行 postProcessAfterInitialization 方法时会遍历容器中所有的切面，查找与当前 Bean 匹配的切面，这里会获取事务的属性切面，也就是 <code>@Transactional</code> 注解及其属性值。</p>
<p>然后根据得到的切面创建一个代理对象，默认使用 JDK 动态代理创建代理，如果目标类是接口，则使用 JDK 动态代理，否则使用 Cglib。</p>
<p>第二步，<strong>在执行目标方法时进行事务增强操作</strong>：</p>
<p>当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-97493c7f-c596-4e98-a6a8-dab254d6d1ab.png" alt="图片来源网易技术专栏" /></p>
<p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，包括开启事务、事务提交、异常回滚等。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东同学 10 后端实习一面的原题：Spring 事务怎么实现的</li>
</ol>
</blockquote>
<h3 id="27声明式事务在哪些情况下会失效"><a class="header" href="#27声明式事务在哪些情况下会失效">27.声明式事务在哪些情况下会失效？</a></h3>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-381e4ec9-a235-4cfa-9b4d-518095a7502a.png" alt="三分恶面渣逆袭：声明式事务的几种失效的情况" /></p>
<h4 id="1transactional-应用在非-public-修饰的方法上"><a class="header" href="#1transactional-应用在非-public-修饰的方法上">1、@Transactional 应用在非 public 修饰的方法上</a></h4>
<p>如果 Transactional 注解应用在非 public 修饰的方法上，Transactional 将会失效。</p>
<p>是因为在 Spring AOP 代理时，TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource 的 <strong>computeTransactionAttribute</strong>方法，获取 Transactional 注解的事务配置信息。</p>
<pre><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method,
    Class&lt;?&gt; targetClass) {
        // Don't allow no-public methods as required.
        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {
        return null;
    }
}
</code></pre>
<p>此方法会检查目标方法的修饰符是否为 public，不是 public 则不会获取 @Transactional 的属性配置信息。</p>
<h4 id="2transactional-注解属性-propagation-设置错误"><a class="header" href="#2transactional-注解属性-propagation-设置错误">2、@Transactional 注解属性 propagation 设置错误</a></h4>
<ul>
<li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行；错误使用场景：在业务逻辑必须运行在事务环境下以确保数据一致性的情况下使用 SUPPORTS。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：总是以非事务方式执行，如果当前存在事务，则挂起该事务。错误使用场景：在需要事务支持的操作中使用 NOT_SUPPORTED。</li>
<li>TransactionDefinition.PROPAGATION_NEVER：总是以非事务方式执行，如果当前存在事务，则抛出异常。错误使用场景：在应该在事务环境下执行的操作中使用 NEVER。</li>
</ul>
<h4 id="3transactional-注解属性-rollbackfor-设置错误"><a class="header" href="#3transactional-注解属性-rollbackfor-设置错误">3、@Transactional 注解属性 rollbackFor 设置错误</a></h4>
<p>rollbackFor 用来指定能够触发事务回滚的异常类型。Spring 默认抛出未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常不会触发回滚事务。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-04053b02-3264-4d7f-b868-560a0333f08d.png" alt="三分恶面渣逆袭：Spring默认支持的异常回滚" /></p>
<pre><code class="language-java">// 希望自定义的异常可以进行回滚
@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class)
</code></pre>
<p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p>
<h4 id="4同一个类中方法调用导致transactional-失效"><a class="header" href="#4同一个类中方法调用导致transactional-失效">4、同一个类中方法调用，导致@Transactional 失效</a></h4>
<p>开发中避免不了会对同一个类里面的方法调用，比如有一个类 Test，它的一个方法 A，A 调用本类的方法 B（不论方法 B 是用 public 还是 private 修饰），但方法 A 没有声明注解事务，而 B 方法有。</p>
<p>则外部调用方法 A 之后，方法 B 的事务是不会起作用的。这也是经常犯错误的一个地方。</p>
<p>那为啥会出现这种情况呢？其实还是由 Spring AOP 代理造成的，因为只有事务方法被当前类以外的代码调用时，才会由 Spring 生成的代理对象来管理。</p>
<pre><code class="language-java"> //@Transactional
@GetMapping("/test")
private Integer A() throws Exception {
    CityInfoDict cityInfoDict = new CityInfoDict();
    cityInfoDict.setCityName("2");
    /**
     * B 插入字段为 3的数据
     */
    this.insertB();
    /**
     * A 插入字段为 2的数据
     */
    int insert = cityInfoDictMapper.insert(cityInfoDict);
    return insert;
}

@Transactional()
public Integer insertB() throws Exception {
    CityInfoDict cityInfoDict = new CityInfoDict();
    cityInfoDict.setCityName("3");
    cityInfoDict.setParentCityId(3);

    return cityInfoDictMapper.insert(cityInfoDict);
}
</code></pre>
<p>这种情况是最常见的一种@Transactional 注解失效场景。</p>
<pre><code class="language-java">@Transactional
private Integer A() throws Exception {
    int insert = 0;
    try {
        CityInfoDict cityInfoDict = new CityInfoDict();
        cityInfoDict.setCityName("2");
        cityInfoDict.setParentCityId(2);
        /**
         * A 插入字段为 2的数据
         */
        insert = cityInfoDictMapper.insert(cityInfoDict);
        /**
         * B 插入字段为 3的数据
        */
        b.insertB();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<p>如果 B 方法内部抛了异常，而 A 方法此时 try catch 了 B 方法的异常，那这个事务就不能正常回滚了，会抛出异常：</p>
<pre><code class="language-java">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米春招同学 K 一面面试原题：事务传播，protected 和 private 加事务会生效吗,还有那些不生效的情况</li>
</ol>
</blockquote>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="mvc"><a class="header" href="#mvc">MVC</a></h2>
<h3 id="28spring-mvc-的核心组件"><a class="header" href="#28spring-mvc-的核心组件">28.Spring MVC 的核心组件？</a></h3>
<ol>
<li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li>
<li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li>
<li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li>
<li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li>
<li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>
<li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li>
<li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>
<li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li>
</ol>
<h3 id="29spring-mvc-的工作流程"><a class="header" href="#29spring-mvc-的工作流程">29.Spring MVC 的工作流程？</a></h3>
<p>首先，客户端发送请求，DispatcherServlet 拦截并通过 HandlerMapping 找到对应的控制器。</p>
<p>DispatcherServlet 使用 HandlerAdapter 调用控制器方法，执行具体的业务逻辑，返回一个 ModelAndView 对象。</p>
<p>然后 DispatcherServlet 通过 ViewResolver 解析视图。</p>
<p>最后，DispatcherServlet 渲染视图并将响应返回给客户端。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-e29a122b-db07-48b8-8289-7251032e87a1.png" alt="三分恶面渣逆袭：Spring MVC的工作流程" /></p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240506102456.png" alt="图片来源于网络：SpringMVC工作流程图" /></p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240506103022.png" alt="_未来可期：SpringMVC工作流程图" /></p>
<p>①、<strong>发起请求</strong>：客户端通过 HTTP 协议向服务器发起请求。</p>
<p>②、<strong>前端控制器</strong>：这个请求会先到前端控制器 DispatcherServlet，它是整个流程的入口点，负责接收请求并将其分发给相应的处理器。</p>
<p>③、<strong>处理器映射</strong>：DispatcherServlet 调用 HandlerMapping 来确定哪个 Controller 应该处理这个请求。通常会根据请求的 URL 来确定。</p>
<p>④、<strong>处理器适配器</strong>：一旦找到目标 Controller，DispatcherServlet 会使用 HandlerAdapter 来调用 Controller 的处理方法。</p>
<p>⑤、<strong>执行处理器</strong>：Controller 处理请求，处理完后返回一个 ModelAndView 对象，其中包含模型数据和逻辑视图名。</p>
<p>⑥、<strong>视图解析器</strong>：DispatcherServlet 接收到 ModelAndView 后，会使用 ViewResolver 来解析视图名称，找到具体的视图页面。</p>
<p>⑦、<strong>渲染视图</strong>：视图使用模型数据渲染页面，生成最终的页面内容。</p>
<p>⑧、<strong>响应结果</strong>：DispatcherServlet 将视图结果返回给客户端。</p>
<p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要我们开发人员创建和管理，真正需要处理的只有 <strong>Controller</strong> 、<strong>View</strong> 、<strong>Model</strong>。</p>
<p>在前后端分离的情况下，步骤 ⑥、⑦、⑧ 会略有不同，后端通常只需要处理数据，并将 JSON 格式的数据返回给前端就可以了，而不是返回完整的视图页面。</p>
<h4 id="这个-handler-是什么东西啊为什么还需要-handleradapter"><a class="header" href="#这个-handler-是什么东西啊为什么还需要-handleradapter">这个 Handler 是什么东西啊？为什么还需要 HandlerAdapter</a></h4>
<p>Handler 一般就是指 Controller，Controller 是 Spring MVC 的核心组件，负责处理请求，返回响应。</p>
<p>Spring MVC 允许使用多种类型的处理器。不仅仅是标准的<code>@Controller</code>注解的类，还可以是实现了特定接口的其他类（如 HttpRequestHandler 或 SimpleControllerHandlerAdapter 等）。这些处理器可能有不同的方法签名和交互方式。</p>
<p>HandlerAdapter 的主要职责就是调用 Handler 的方法来处理请求，并且适配不同类型的处理器。HandlerAdapter 确保 DispatcherServlet 可以以统一的方式调用不同类型的处理器，无需关心具体的执行细节。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯 Java 后端实习一面原题：说说前端发起请求到 SpringMVC 的整个处理流程。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的国企面试原题：说说 SpringMVC 的流程吧</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小公司面经同学 5 Java 后端面试原题：springMVC 工作流程 我大概就是按面渣逆袭里答的，答到一半打断我：然后会有个 Handler，这个 Handler 是什么东西啊。前面 Handler 不是已经知道 controller 了吗，我直接执行不就行了，为什么还要 Adapter 呢。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 8 面试原题：SpringMVC框架</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 17 后端技术面试原题：springmvc执行流程</li>
</ol>
</blockquote>
<h3 id="30springmvc-restful-风格的接口的流程是什么样的呢"><a class="header" href="#30springmvc-restful-风格的接口的流程是什么样的呢">30.SpringMVC Restful 风格的接口的流程是什么样的呢？</a></h3>
<p>PS:这是一道全新的八股，毕竟 ModelAndView 这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。</p>
<p>我们都知道 Restful 接口，响应格式是 json，这就用到了一个常用注解：<strong>@ResponseBody</strong></p>
<pre><code class="language-java">    @GetMapping("/user")
    @ResponseBody
    public User user(){
        return new User(1,"张三");
    }
</code></pre>
<p>加入了这个注解后，整体的流程上和使用 ModelAndView 大体上相同，但是细节上有一些不同：</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-2da963a0-5da9-4b3a-aafd-fd8dbc7e1807.png" alt="Spring MVC Restful请求响应示意图" /></p>
<ol>
<li>
<p>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet</p>
</li>
<li>
<p>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理</p>
</li>
<li>
<p>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</p>
</li>
<li>
<p>Controller 被封装成了 ServletInvocableHandlerMethod，HandlerAdapter 处理器适配器去执行 invokeAndHandle 方法，完成对 Controller 的请求处理</p>
</li>
<li>
<p>HandlerAdapter 执行完对 Controller 的请求，会调用 HandlerMethodReturnValueHandler 去处理返回值，主要的过程：</p>
<p>5.1. 调用 RequestResponseBodyMethodProcessor，创建 ServletServerHttpResponse（Spring 对原生 ServerHttpResponse 的封装）实例</p>
<p>5.2.使用 HttpMessageConverter 的 write 方法，将返回值写入 ServletServerHttpResponse 的 OutputStream 输出流中</p>
<p>5.3.在写入的过程中，会使用 JsonGenerator（默认使用 Jackson 框架）对返回值进行 Json 序列化</p>
</li>
<li>
<p>执行完请求后，返回的 ModealAndView 为 null，ServletServerHttpResponse 里也已经写入了响应，所以不用关心 View 的处理</p>
</li>
</ol>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="spring-boot"><a class="header" href="#spring-boot">Spring Boot</a></h2>
<h3 id="31介绍一下-springboot有哪些优点"><a class="header" href="#31介绍一下-springboot有哪些优点">31.介绍一下 SpringBoot，有哪些优点？</a></h3>
<p>Spring Boot 提供了一套默认配置，它通过约定大于配置的理念，来帮助我们快速搭建 Spring 项目骨架。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-d9164ee6-5c86-4313-8fd9-efb9acfa5f0b.png" alt="SpringBoot图标" /></p>
<p>以前的 Spring 开发需要配置大量的 xml 文件，并且需要引入大量的第三方 jar 包，还需要手动放到 classpath 下。现在只需要引入一个 Starter，或者一个注解，就可以轻松搞定。</p>
<p>Spring Boot 的优点非常多，比如说：</p>
<ol>
<li>Spring Boot 内嵌了 Tomcat、Jetty、Undertow 等容器，直接运行 jar 包就可以启动项目。</li>
<li>Spring Boot 内置了 Starter 和自动装配，避免繁琐的手动配置。例如，如果项目中添加了 spring-boot-starter-web，Spring Boot 会自动配置 Tomcat 和 Spring MVC。</li>
<li>Spring Boot 内置了 Actuator 和 DevTools，便于调试和监控。</li>
</ol>
<h4 id="spring-boot常用注解有哪些"><a class="header" href="#spring-boot常用注解有哪些">Spring Boot常用注解有哪些？</a></h4>
<ol>
<li><strong>@SpringBootApplication</strong>：Spring Boot 应用的入口，用在启动类上。</li>
<li>还有一些 Spring 框架本身的注解，比如 <strong>@Component</strong>、<strong>@RestController</strong>、<strong>@Service</strong>、<strong>@ConfigurationProperties</strong>、<strong>@Transactional</strong> 等。</li>
</ol>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的华为 OD 面经中出现过该题：讲讲 Spring Boot 的特性。</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：SpringBoot基本原理</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的国企零碎面经同学 9 面试原题：Springboot基于Spring的配置有哪几种</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里云面经同学 22 面经：springboot常用注解</li>
</ol>
</blockquote>
<h3 id="32springboot-自动配置原理了解吗"><a class="header" href="#32springboot-自动配置原理了解吗">32.SpringBoot 自动配置原理了解吗？</a></h3>
<p>在 Spring 中，自动装配是指容器利用反射技术，根据 Bean 的类型、名称等自动注入所需的依赖。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-df77ee15-2ff0-4ec7-8e65-e4ebb8ba88f1.png" alt="三分恶面渣逆袭：SpringBoot自动配置原理" /></p>
<p>在 Spring Boot 中，开启自动装配的注解是<code>@EnableAutoConfiguration</code>。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240316121711.png" alt="二哥的 Java 进阶之路：@EnableAutoConfiguration 源码" /></p>
<p>Spring Boot 为了进一步简化，直接通过 <code>@SpringBootApplication</code> 注解一步搞定，该注解包含了 <code>@EnableAutoConfiguration</code> 注解。</p>
<p>main 类启动的时候，Spring Boot 会通过底层的<code>AutoConfigurationImportSelector</code> 类加载自动装配类。</p>
<pre><code class="language-java">@AutoConfigurationPackage //将main同级的包下的所有组件注册到容器中
@Import({AutoConfigurationImportSelector.class}) //加载自动装配类 xxxAutoconfiguration
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class&lt;?&gt;[] exclude() default {};

    String[] excludeName() default {};
}
</code></pre>
<p><code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，该接口的作用是收集需要导入的配置类，配合 <code>@Import()</code> 将相应的类导入到 Spring 容器中。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240316122134.png" alt="二哥的 Java 进阶之路：AutoConfigurationImportSelector源码" /></p>
<p>获取注入类的方法是 <code>selectImports()</code>，它实际调用的是<code>getAutoConfigurationEntry()</code>，这个方法是获取自动装配类的关键。</p>
<pre><code class="language-java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
    // 检查自动配置是否启用。如果@ConditionalOnClass等条件注解使得自动配置不适用于当前环境，则返回一个空的配置条目。
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }

    // 获取启动类上的@EnableAutoConfiguration注解的属性，这可能包括对特定自动配置类的排除。
    AnnotationAttributes attributes = getAttributes(annotationMetadata);

    // 从spring.factories中获取所有候选的自动配置类。这是通过加载META-INF/spring.factories文件中对应的条目来实现的。
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);

    // 移除配置列表中的重复项，确保每个自动配置类只被考虑一次。
    configurations = removeDuplicates(configurations);

    // 根据注解属性解析出需要排除的自动配置类。
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);

    // 检查排除的类是否存在于候选配置中，如果存在，则抛出异常。
    checkExcludedClasses(configurations, exclusions);

    // 从候选配置中移除排除的类。
    configurations.removeAll(exclusions);

    // 应用过滤器进一步筛选自动配置类。过滤器可能基于条件注解如@ConditionalOnBean等来排除特定的配置类。
    configurations = getConfigurationClassFilter().filter(configurations);

    // 触发自动配置导入事件，允许监听器对自动配置过程进行干预。
    fireAutoConfigurationImportEvents(configurations, exclusions);

    // 创建并返回一个包含最终确定的自动配置类和排除的配置类的AutoConfigurationEntry对象。
    return new AutoConfigurationEntry(configurations, exclusions);
}
</code></pre>
<p>总结：Spring Boot 的自动装配原理依赖于 Spring 框架的依赖注入和条件注册，通过这种方式，Spring Boot 能够智能地配置 bean，并且只有当这些 bean 实际需要时才会被创建和配置。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的滴滴同学 2 技术二面的原题：SpringBoot 启动时为什么能够自动装配</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Spring Boot 如何做到启动的时候注入一些 bean</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪面经同学 3 Java 技术一面面试原题：说一下 Spring Boot 的自动装配原理</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的农业银行同学 1 面试原题：spring boot 的自动装配</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的百度面经同学 1 文心一言 25 实习 Java 后端面试原题：SpringBoot如何实现自动装配</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的 OPPO 面经同学 1 面试原题：自动配置怎么实现的？</li>
</ol>
</blockquote>
<h3 id="33如何自定义一个-springboot-srarter"><a class="header" href="#33如何自定义一个-springboot-srarter">33.如何自定义一个 SpringBoot Srarter?</a></h3>
<p>创建一个自定义的 Spring Boot Starter，需要这几步：</p>
<p>第一步，创建一个新的 Maven 项目，例如命名为 my-spring-boot-starter。在 pom.xml 文件中添加必要的依赖和配置：</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;spring.boot.version&gt;2.3.1.RELEASE&lt;/spring.boot.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
        &lt;version&gt;${spring.boot.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;${spring.boot.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>第二步，在 <code>src/main/java</code> 下创建一个自动配置类，比如 MyServiceAutoConfiguration.java：（通常是 autoconfigure 包下）。</p>
<pre><code class="language-java">@Configuration
@EnableConfigurationProperties(MyStarterProperties.class)
public class MyServiceAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public MyService myService(MyStarterProperties properties) {
        return new MyService(properties.getMessage());
    }
}
</code></pre>
<p>第三步，创建一个配置属性类 MyStarterProperties.java：</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = "mystarter")
public class MyStarterProperties {
    private String message = "二哥的 Java 进阶之路不错啊!";

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</code></pre>
<p>第四步，创建一个简单的服务类 MyService.java：</p>
<pre><code class="language-java">public class MyService {
    private final String message;

    public MyService(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}
</code></pre>
<p>第五步，配置 spring.factories，在 <code>src/main/resources/META-INF</code> 目录下创建 spring.factories 文件，并添加：</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.itwanger.mystarter.autoconfigure.MyServiceAutoConfiguration
</code></pre>
<p>第六步，使用 Maven 打包这个项目：</p>
<pre><code class="language-shell">mvn clean install
</code></pre>
<p>第七步，在其他的 Spring Boot 项目中，通过 Maven 来添加这个自定义的 Starter 依赖，并通过 application.properties 配置欢迎消息：</p>
<pre><code class="language-xml">mystarter.message=javabetter.cn
</code></pre>
<p>然后就可以在 Spring Boot 项目中注入 MyStarterProperties 来使用它。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240409114642.png" alt="" /></p>
<p>启动项目，然后在浏览器中输入 <code>localhost:8081/hello</code>，就可以看到欢迎消息了。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240409114610.png" alt="二哥的 Java 进阶之路" /></p>
<h4 id="spring-boot-starter-的原理了解吗"><a class="header" href="#spring-boot-starter-的原理了解吗">Spring Boot Starter 的原理了解吗？</a></h4>
<p>Spring Boot Starter 主要通过起步依赖和自动配置机制来简化项目的构建和配置过程。</p>
<p>起步依赖是 Spring Boot 提供的一组预定义依赖项，它们将一组相关的库和模块打包在一起。比如 <code>spring-boot-starter-web</code> 就包含了 Spring MVC、Tomcat 和 Jackson 等依赖。</p>
<p>自动配置机制是 Spring Boot 的核心特性，通过自动扫描类路径下的类、资源文件和配置文件，自动创建和配置应用程序所需的 Bean 和组件。</p>
<p>比如有了 <code>spring-boot-starter-web</code>，我们开发者就不需要再手动配置 Tomcat、Spring MVC 等，Spring Boot 会自动帮我们完成这些工作。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动面经同学 1 Java 后端技术一面面试原题：你封装过 springboot starter 吗？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯云智面经同学 20 二面面试原题：Spring Boot Starter 的原理了解吗？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的快手同学 4 一面原题：为什么使用SpringBoot？SpringBoot自动装配的原理及流程？@Import的作用？如果想让SpringBoot对自定义的jar包进行自动配置的话，需要怎么做？</li>
</ol>
</blockquote>
<h3 id="34spring-boot-启动原理了解吗"><a class="header" href="#34spring-boot-启动原理了解吗">34.Spring Boot 启动原理了解吗？</a></h3>
<p>Spring Boot 的启动由 SpringApplication 类负责：</p>
<ul>
<li>第一步，创建 SpringApplication 实例，负责应用的启动和初始化；</li>
<li>第二步，从 application.yml 中加载配置文件和环境变量；</li>
<li>第三步，创建上下文环境 ApplicationContext，并加载 Bean，完成依赖注入；</li>
<li>第四步，启动内嵌的 Web 容器。</li>
<li>第五步，发布启动完成事件 ApplicationReadyEvent，并调用 ApplicationRunner 的 run 方法完成启动后的逻辑。</li>
</ul>
<p>关键的代码逻辑如下：</p>
<pre><code class="language-java">public ConfigurableApplicationContext run(String... args) {
    // 1. 创建启动时的监听器并触发启动事件
    SpringApplicationRunListeners listeners = getRunListeners(args);
    listeners.starting();

    // 2. 准备运行环境
    ConfigurableEnvironment environment = prepareEnvironment(listeners);
    configureIgnoreBeanInfo(environment);

    // 3. 创建上下文
    ConfigurableApplicationContext context = createApplicationContext();

    try {
        // 4. 准备上下文
        prepareContext(context, environment, listeners, args);

        // 5. 刷新上下文，完成 Bean 初始化和装配
        refreshContext(context);

        // 6. 调用运行器
        afterRefresh(context, args);

        // 7. 触发启动完成事件
        listeners.started(context);
    } catch (Exception ex) {
        handleRunFailure(context, ex, listeners);
    }

    return context;
}
</code></pre>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-68744556-a1ba-4e1f-a092-1582875f0da6.png" alt="SpringBoot 启动大致流程-图片来源网络" /></p>
<p>以<a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>为例。在启动类 QuickForumApplication 中，main 方法会调用 <code>SpringApplication.run()</code> 启动项目。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240422090338.png" alt="技术派实战项目源码：启动类" /></p>
<p>该方法负责 Spring 应用的上下文环境（ApplicationContext）准备，包括：</p>
<ul>
<li>扫描配置文件，添加依赖项</li>
<li>初始化和加载 Bean 定义</li>
<li>启动内嵌的 Web 容器等</li>
<li>发布启动完成事件</li>
</ul>
<h4 id="了解springbootapplication-注解吗"><a class="header" href="#了解springbootapplication-注解吗">了解@SpringBootApplication 注解吗？</a></h4>
<p><code>@SpringBootApplication</code>是 Spring Boot 的核心注解，经常用于主类上，作为项目启动入口的标识。它是一个组合注解：</p>
<ul>
<li><code>@SpringBootConfiguration</code>：继承自 <code>@Configuration</code>，标注该类是一个配置类，相当于一个 Spring 配置文件。</li>
<li><code>@EnableAutoConfiguration</code>：告诉 Spring Boot 根据 pom.xml 中添加的依赖自动配置项目。例如，如果 spring-boot-starter-web 依赖被添加到项目中，Spring Boot 会自动配置 Tomcat 和 Spring MVC。</li>
<li><code>@ComponentScan</code>：扫描当前包及其子包下被<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 注解标记的类，并注册为 Spring Bean。</li>
</ul>
<pre><code class="language-java">@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>
<h4 id="为什么-spring-boot-在启动的时候能够找到-main-方法上的springbootapplication-注解"><a class="header" href="#为什么-spring-boot-在启动的时候能够找到-main-方法上的springbootapplication-注解">为什么 Spring Boot 在启动的时候能够找到 main 方法上的@SpringBootApplication 注解？</a></h4>
<p>Spring Boot 在启动时能够找到主类上的<code>@SpringBootApplication</code>注解，是因为它利用了 Java 的反射机制和类加载机制，结合 Spring 框架内部的一系列处理流程。</p>
<p>当运行一个 Spring Boot 程序时，通常会调用主类中的<code>main</code>方法，这个方法会执行<code>SpringApplication.run()</code>，比如：</p>
<pre><code class="language-java">@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
<p><code>SpringApplication.run(Class&lt;?&gt; primarySource, String... args)</code>方法接收两个参数：第一个是主应用类（即包含<code>main</code>方法的类），第二个是命令行参数。<code>primarySource</code>参数提供了一个起点，Spring Boot 通过它来加载应用上下文。</p>
<p>Spring Boot 利用 Java 反射机制来读取传递给<code>run</code>方法的类（<code>MyApplication.class</code>）。它会检查这个类上的注解，包括<code>@SpringBootApplication</code>。</p>
<h4 id="spring-boot-默认的包扫描路径是什么"><a class="header" href="#spring-boot-默认的包扫描路径是什么">Spring Boot 默认的包扫描路径是什么？</a></h4>
<p>Spring Boot 的默认包扫描路径是以启动类 <code>@SpringBootApplication</code> 注解所在的包为根目录的，即默认情况下，Spring Boot 会扫描启动类所在包及其子包下的所有组件。</p>
<p>比如说在<a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，启动类<code>QuickForumApplication</code>所在的包是<code>com.github.paicoding.forum.web</code>，那么 Spring Boot 默认会扫描<code>com.github.paicoding.forum.web</code>包及其子包下的所有组件。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240327105552.png" alt="沉默王二：技术派项目截图" /></p>
<p><code>@SpringBootApplication</code> 是一个组合注解，它里面的<code>@ComponentScan</code>注解可以指定要扫描的包路径，默认扫描启动类所在包及其子包下的所有组件。</p>
<pre><code class="language-java">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
}
</code></pre>
<p>比如说带有 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 等注解的类都会被 Spring Boot 扫描到，并注册到 Spring 容器中。</p>
<p>如果需要自定义包扫描路径，可以在<code>@SpringBootApplication</code>注解上添加<code>@ComponentScan</code>注解，指定要扫描的包路径。</p>
<pre><code class="language-java">@SpringBootApplication
@ComponentScan(basePackages = {"com.github.paicoding.forum"})
public class QuickForumApplication {
    public static void main(String[] args) {
        SpringApplication.run(QuickForumApplication.class, args);
    }
}
</code></pre>
<p>这种方式会覆盖默认的包扫描路径，只扫描<code>com.github.paicoding.forum</code>包及其子包下的所有组件。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的滴滴同学 2 技术二面的原题：为什么 Spring Boot 启动时能找到 Main 类上面的注解</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的腾讯面经同学 22 暑期实习一面面试原题：Spring Boot 默认的包扫描路径？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的微众银行同学 1 Java 后端一面的原题：@SpringBootApplication 注解了解吗？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的国企零碎面经同学 9 面试原题：Springboot的工作原理？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：SpringBoot启动流程（忘了）</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的哔哩哔哩同学 1 二面面试原题：springBoot启动机制，启动之后做了哪些步骤</li>
</ol>
</blockquote>
<h3 id="36springboot-和-springmvc-的区别补充"><a class="header" href="#36springboot-和-springmvc-的区别补充">36.SpringBoot 和 SpringMVC 的区别？（补充）</a></h3>
<blockquote>
<p>2024 年 04 月 04 日增补</p>
</blockquote>
<p>Spring MVC 是基于 Spring 框架的一个模块，提供了一种 Model-View-Controller（模型-视图-控制器）的开发模式。</p>
<p>Spring Boot 旨在简化 Spring 应用的配置和部署过程，提供了大量的自动配置选项，以及运行时环境的内嵌 Web 服务器，这样就可以更快速地开发一个 SpringMVC 的 Web 项目。</p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的滴滴同学 2 技术二面的原题：SpringBoot 和 SpringMVC 的区别</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的京东面经同学 5 Java 后端技术一面面试原题：SpringBoot与SpringMVC区别（不会）</li>
</ol>
</blockquote>
<h3 id="38spring-boot-和-spring-有什么区别补充"><a class="header" href="#38spring-boot-和-spring-有什么区别补充">38.Spring Boot 和 Spring 有什么区别？（补充）</a></h3>
<blockquote>
<p>2024 年 07 月 09 日新增</p>
</blockquote>
<p>Spring Boot 是 Spring Framework 的一个扩展，提供了一套快速配置和开发的机制，可以帮助我们快速搭建 Spring 项目的骨架，提高生产效率。</p>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>Spring Framework</th><th>Spring Boot</th></tr></thead><tbody>
<tr><td><strong>目的</strong></td><td>提供企业级的开发工具和库</td><td>简化 Spring 应用的开发、配置和部署</td></tr>
<tr><td><strong>配置方式</strong></td><td>主要通过 XML 和注解等手动配置</td><td>提供开箱即用的自动配置</td></tr>
<tr><td><strong>启动和运行</strong></td><td>需要打成 war 包到 Tomcat 等容器下运行</td><td>已嵌入 Tomcat 等容器，打包成 JAR 文件直接运行</td></tr>
<tr><td><strong>依赖管理</strong></td><td>手动添加和管理依赖</td><td>使用 <code>spring-boot-starter</code> 简化依赖管理</td></tr>
</tbody></table>
</div>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的小米同学 F 面试原题：Spring Boot 和 Spring 的区别</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的 OPPO 面经同学 1 面试原题：说一下Spring和Springboot之间有什么差异？</li>
</ol>
</blockquote>
<h2 id="spring-cloud"><a class="header" href="#spring-cloud">Spring Cloud</a></h2>
<h3 id="35对-springcloud-了解多少"><a class="header" href="#35对-springcloud-了解多少">35.对 SpringCloud 了解多少？</a></h3>
<p>Spring Cloud 是一个基于 Spring Boot，提供构建分布式系统和微服务架构的工具集。用于解决分布式系统中的一些常见问题，如配置管理、服务发现、负载均衡等等。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-92ab53d5-f303-4fc5-bd26-e62cefe374b3.png" alt="三分恶面渣逆袭：Spring Cloud Netfilx核心组件" /></p>
<h4 id="什么是微服务"><a class="header" href="#什么是微服务">什么是微服务？</a></h4>
<ol>
<li>2014 年 <strong>Martin Fowler</strong> 提出的一种新的架构形式。微服务架构是一种<strong>架构模式</strong>，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如 HTTP 或 Dubbo)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如 Maven)对其进行构建。</li>
<li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li>
</ol>
<h4 id="微服务架构主要要解决哪些问题"><a class="header" href="#微服务架构主要要解决哪些问题">微服务架构主要要解决哪些问题？</a></h4>
<ol>
<li>服务很多，客户端怎么访问，如何提供对外网关?</li>
<li>这么多服务，服务之间如何通信? HTTP 还是 RPC?</li>
<li>这么多服务，如何治理? 服务的注册和发现。</li>
<li>服务挂了怎么办？熔断机制。</li>
</ol>
<h4 id="有哪些主流微服务框架"><a class="header" href="#有哪些主流微服务框架">有哪些主流微服务框架？</a></h4>
<ol>
<li>Spring Cloud Netflix</li>
<li>Spring Cloud Alibaba</li>
<li>SpringBoot + Dubbo + ZooKeeper</li>
</ol>
<h4 id="springcloud-有哪些核心组件"><a class="header" href="#springcloud-有哪些核心组件">SpringCloud 有哪些核心组件？</a></h4>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/spring-2b988a72-0739-4fed-b271-eaf12589444f.png" alt="SpringCloud" /></p>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的比亚迪同学 1 面试原题：SpringCloud 了解多少？</li>
</ol>
</blockquote>
<h2 id="补充"><a class="header" href="#补充">补充</a></h2>
<h3 id="37springtask-了解吗"><a class="header" href="#37springtask-了解吗">37.SpringTask 了解吗？</a></h3>
<p>SpringTask 是 Spring 框架提供的一个轻量级的任务调度框架，它允许我们开发者通过简单的注解来配置和管理定时任务。</p>
<p>①、<code>@Scheduled</code>：最常用的注解，用于标记方法为计划任务的执行点。<a href="https://javabetter.cn/zhishixingqiu/paicoding.html">技术派实战项目</a>中，就使用该注解来定时刷新 sitemap.xml：</p>
<pre><code class="language-java">@Scheduled(cron = "0 15 5 * * ?")
public void autoRefreshCache() {
    log.info("开始刷新sitemap.xml的url地址，避免出现数据不一致问题!");
    refreshSitemap();
    log.info("刷新完成！");
}
</code></pre>
<p><code>@Scheduled</code> 注解支持多种调度选项，如 fixedRate、fixedDelay 和 cron 表达式。</p>
<p>②、<code>@EnableScheduling</code>：用于开启定时任务的支持。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20240422094511.png" alt="技术派的启动类就有该注解的影子" /></p>
<h4 id="用springtask资源占用太高有什么其他的方式解决补充"><a class="header" href="#用springtask资源占用太高有什么其他的方式解决补充">用SpringTask资源占用太高，有什么其他的方式解决？（补充）</a></h4>
<blockquote>
<p>2024年05月27日新增</p>
</blockquote>
<p><strong>第一，使用消息队列</strong>，如 RabbitMQ、Kafka、RocketMQ 等，将任务放到消息队列中，然后由消费者异步处理这些任务。</p>
<p>①、在订单创建时，将订单超时检查任务放入消息队列，并设置延迟时间（即订单超时时间）。</p>
<pre><code class="language-java">@Service
public class OrderService {
    @Autowired
    private RabbitTemplate rabbitTemplate;

    public void createOrder(Order order) {
        // 创建订单逻辑
        // ...
        
        // 发送延迟消息
        rabbitTemplate.convertAndSend("orderExchange", "orderTimeoutQueue", order, message -&gt; {
            message.getMessageProperties().setExpiration("600000"); // 设置延迟时间（10分钟）
            return message;
        });
    }
}
</code></pre>
<p>②、使用消费者从队列中消费消息，当消费到超时任务时，执行订单超时处理逻辑。</p>
<pre><code class="language-java">@Service
public class OrderTimeoutConsumer {

    @RabbitListener(queues = "orderTimeoutQueue")
    public void handleOrderTimeout(Order order) {
        // 处理订单超时逻辑
        // ...
    }
}
</code></pre>
<p><strong>第二，使用数据库调度器（如 Quartz）</strong>。</p>
<p>①、创建一个 Quartz 任务类，处理订单超时逻辑。</p>
<pre><code class="language-java">public class OrderTimeoutJob implements Job {
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        // 获取订单信息
        Order order = (Order) context.getJobDetail().getJobDataMap().get("order");

        // 处理订单超时逻辑
        // ...
    }
}
</code></pre>
<p>②、在订单创建时，调度一个 Quartz 任务，设置任务的触发时间为订单超时时间。</p>
<pre><code class="language-java">@Service
public class OrderService {
    @Autowired
    private Scheduler scheduler;

    public void createOrder(Order order) {
        // 创建订单逻辑
        // ...

        // 调度 Quartz 任务
        JobDetail jobDetail = JobBuilder.newJob(OrderTimeoutJob.class)
                .usingJobData("order", order)
                .build();

        Trigger trigger = TriggerBuilder.newTrigger()
                .startAt(new Date(System.currentTimeMillis() + 600000)) // 设置触发时间（10分钟后）
                .build();

        try {
            scheduler.scheduleJob(jobDetail, trigger);
        } catch (SchedulerException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的微众银行同学 1 Java 后端一面的原题：SpringTask 了解吗？</li>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的阿里面经同学 1 闲鱼后端一面的原题：订单超时，用springtask资源占用太高，有什么其他的方式解决?</li>
</ol>
</blockquote>
<h3 id="41spring-cache-了解吗"><a class="header" href="#41spring-cache-了解吗">41.Spring Cache 了解吗？</a></h3>
<p>Spring Cache 是 Spring 框架提供的一个缓存抽象，它通过统一的接口来支持多种缓存实现（如 Redis、Caffeine 等）。</p>
<p>它通过注解（如 <code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>）来实现缓存管理，极大简化了代码实现。</p>
<ul>
<li>@Cacheable：缓存方法的返回值。</li>
<li>@CachePut：用于更新缓存，每次调用方法都会将结果重新写入缓存。</li>
<li>@CacheEvict：用于删除缓存。</li>
</ul>
<p>使用示例：</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241031111306.png" alt="二哥的Java 进阶之路：Spring Cache" /></p>
<h4 id="spring-cache-和-redis-有什么区别"><a class="header" href="#spring-cache-和-redis-有什么区别">Spring Cache 和 Redis 有什么区别？</a></h4>
<ol>
<li><strong>Spring Cache</strong> 是 Spring 框架提供的一个缓存抽象，它通过注解来实现缓存管理，支持多种缓存实现（如 Redis、Caffeine 等）。</li>
<li><strong>Redis</strong> 是一个分布式的缓存中间件，支持多种数据类型（如 String、Hash、List、Set、ZSet），还支持持久化、集群、主从复制等。</li>
</ol>
<p>Spring Cache 适合用于单机、轻量级和短时缓存场景，能够通过注解轻松控制缓存管理。</p>
<p>Redis 是一种分布式缓存解决方案，支持多种数据结构和高并发访问，适合分布式系统和高并发场景，可以提供数据持久化和多种淘汰策略。</p>
<p>在实际开发中，Spring Cache 和 Redis 可以结合使用，Spring Cache 提供管理缓存的注解，而 Redis 则作为分布式缓存的实现，提供共享缓存支持。</p>
<h4 id="有了-redis-为什么还需要-spring-cache"><a class="header" href="#有了-redis-为什么还需要-spring-cache">有了 Redis 为什么还需要 Spring Cache？</a></h4>
<p>虽然 Redis 非常强大，但 Spring Cache 提供了一层缓存抽象，简化了缓存的管理。我们可以直接在方法上通过注解来实现缓存逻辑，减少了手动操作 Redis 的代码量。</p>
<p>Spring Cache 还能灵活切换底层缓存实现。此外，Spring Cache 支持事务性缓存和条件缓存，便于在复杂场景中确保数据一致性。</p>
<h4 id="说说spring-cache-的底层原理"><a class="header" href="#说说spring-cache-的底层原理">说说Spring Cache 的底层原理？</a></h4>
<p>Spring Cache 是基于 AOP 和缓存抽象层实现的。它通过 AOP 拦截被 @Cacheable、@CachePut 和 @CacheEvict 注解的方法，在方法调用前后自动执行缓存逻辑。</p>
<p><img src="https://cdn.tobebetterjavaer.com/stutymore/spring-20241031113743.png" alt="铿然架构：Spring Cache 架构" /></p>
<p>其提供的 CacheManager 和 Cache 等接口，不依赖具体的缓存实现，因此可以灵活地集成 Redis、Caffeine 等多种缓存。</p>
<ul>
<li>ConcurrentMapCacheManager：基于 Java ConcurrentMap 的本地缓存实现。</li>
<li>RedisCacheManager：基于 Redis 的分布式缓存实现。</li>
<li>CaffeineCacheManager：基于 Caffeine 的缓存实现。</li>
</ul>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的美团同学 9 一面面试原题：介绍一下springcache 和redis？Spring cache和redis之间的各应用在什么场景？有了redis为什么还要用springcahe？springcache 底层原理，基于什么实现的？</li>
</ol>
</blockquote>
<hr />
<p>图文详解 41 道 Spring 面试高频题，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳<a href="https://mp.weixin.qq.com/s/EQge6DmgIqYITM3mAxkatg">转载链接</a>，作者：三分恶，戳<a href="https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ">原文链接</a>。</p>
<p><em>没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟</em>。</p>
<p><strong>系列内容</strong>：</p>
<ul>
<li><a href="https://javabetter.cn/sidebar/sanfene/javase.html">面渣逆袭 Java SE 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/javathread.html">面渣逆袭 Java 集合框架篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/collection.html">面渣逆袭 Java 并发编程篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/jvm.html">面渣逆袭 JVM 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/spring.html">面渣逆袭 Spring 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/redis.html">面渣逆袭 Redis 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/mybatis.html">面渣逆袭 MyBatis 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/mysql.html">面渣逆袭 MySQL 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/os.html">面渣逆袭操作系统篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/network.html">面渣逆袭计算机网络篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/rocketmq.html">面渣逆袭 RocketMQ 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/fenbushi.html">面渣逆袭分布式篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/weifuwu.html">面渣逆袭微服务篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/shejimoshi.html">面渣逆袭设计模式篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/linux.html">面渣逆袭 Linux 篇 👍</a></li>
</ul>
<hr />
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="weifuwu.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="protobuff.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="weifuwu.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="protobuff.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
