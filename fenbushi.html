<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>分布式</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<p>title: 分布式面试题，12道分布式八股文（8千字25张手绘图），面渣逆袭必看👍
shortTitle: 面渣逆袭-分布式
author: 三分恶
category:</p>
<ul>
<li>面渣逆袭
tag:</li>
<li>面渣逆袭
description: 下载次数超 1 万次，8800 字 25 张手绘图，详解 12 道分布式面试高频题（让天下没有难背的八股），面渣背会这些八股文，这次吊打面试官，我觉得稳了（手动 dog）。
head:</li>
<li>
<ul>
<li>meta</li>
<li>name: keywords
content: Java,分布式,Java面试题,分布式面试题,面试题,八股文,java</li>
</ul>
</li>
</ul>
<hr />
<p>8800 字 25 张手绘图，详解 12 道分布式面试高频题（让天下没有难背的八股），面渣背会这些八股文，这次吊打面试官，我觉得稳了（手动 dog）。整理：沉默王二，戳<a href="https://mp.weixin.qq.com/s/nLwHEmVGtl-2FDugMqYs3A">转载链接</a>，作者：三分恶，戳<a href="https://mp.weixin.qq.com/s/d84tWIjbcGKhwUptzkO2hQ">原文链接</a>。</p>
<h2 id="分布式理论"><a class="header" href="#分布式理论">分布式理论</a></h2>
<h3 id="1-说说-cap-原则"><a class="header" href="#1-说说-cap-原则">1. 说说 CAP 原则？</a></h3>
<p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这 3 个基本需求，最多只能同时满足其中的 2 个。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-6b0609de-e2ce-4778-b76f-018af80c617f.jpg" alt="" /></p>
<div class="table-wrapper"><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody>
<tr><td>Consistency（一致性）</td><td>指数据在多个副本之间能够保持一致的特性（严格的一致性）</td></tr>
<tr><td>Availability（可用性）</td><td>指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）</td></tr>
<tr><td>Partition tolerance（分区容错性）</td><td>分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障</td></tr>
</tbody></table>
</div>
<h3 id="2-为什么-cap-不可兼得呢"><a class="header" href="#2-为什么-cap-不可兼得呢">2. 为什么 CAP 不可兼得呢？</a></h3>
<p>首先对于分布式系统，分区是必然存在的，所谓分区指的是分布式系统可能出现的字区域网络不通，成为孤立区域的的情况。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-49bf971a-63ae-4b45-bb9e-8af84dff7219.jpg" alt="" /></p>
<p>那么分区容错性（<strong>P</strong>）就必须要满足，因为如果要牺牲分区容错性，就得把服务和资源放到一个机器，或者一个“同生共死”的集群，那就违背了分布式的初衷。</p>
<p>那么满足分区容错的基础上，能不能同时满足<code>一致性</code>和<code>可用性</code>？</p>
<p>假如现在有两个分区<code>N1</code>和<code>N2</code>，N1 和 N2 分别有不同的分区存储 D1 和 D2，以及不同的服务 S1 和 S2。</p>
<ul>
<li>在满足<code>一致性</code> 的时候，N1 和 N2 的数据要求值一样的，D1=D2。</li>
<li>在满足<code>可用性</code>的时候，无论访问 N1 还是 N2，都能获取及时的响应。</li>
</ul>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-428f55c0-368d-4d07-a5a5-a17f7bd327b7.jpg" alt="" /></p>
<p>假如现在有这样的场景：</p>
<ul>
<li>用户访问了 N1，修改了 D1 的数据。</li>
<li>用户再次访问，请求落在了 N2。此时 D1 和 D2 的数据不一致。</li>
</ul>
<p>接下来：</p>
<ul>
<li>保证<code>一致性</code>：此时 D1 和 D2 数据不一致，要保证一致性就不能返回不一致的数据，<code>可用性</code>无法保证。</li>
<li>保证<code>可用性</code>：立即响应，可用性得到了保证，但是此时响应的数据和 D1 不一致，<code>一致性</code>无法保证。</li>
</ul>
<p>所以，可以看出，分区容错的前提下，<code>一致性</code>和<code>可用性</code>是矛盾的。</p>
<h3 id="3-cap-对应的模型和应用"><a class="header" href="#3-cap-对应的模型和应用">3. CAP 对应的模型和应用？</a></h3>
<p><strong>CA without P</strong></p>
<p>理论上放弃 P（分区容错性），则 C（强一致性）和 A（可用性）是可以保证的。实际上分区是不可避免的，严格上 CA 指的是允许分区后各子系统依然保持 CA。</p>
<p>CA 模型的常见应用：</p>
<ul>
<li>集群数据库</li>
<li>xFS 文件系统</li>
</ul>
<p><strong>CP without A</strong></p>
<p>放弃 A（可用），相当于每个请求都需要在 Server 之间强一致，而 P（分区）会导致同步时间无限延长，如此 CP 也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p>
<p>CP 模型的常见应用：</p>
<ul>
<li>分布式数据库</li>
<li>分布式锁</li>
</ul>
<p><strong>AP wihtout C</strong></p>
<p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的 NoSQL 都属于此类。</p>
<p>AP 模型常见应用：</p>
<ul>
<li>Web 缓存</li>
<li>DNS</li>
</ul>
<p>举个大家更熟悉的例子，像我们熟悉的注册中心<code>ZooKeeper</code>、<code>Eureka</code>、<code>Nacos</code>中：</p>
<ul>
<li>ZooKeeper 保证的是 CP</li>
<li>Eureka 保证的则是 AP</li>
<li>Nacos 不仅支持 CP 也支持 AP</li>
</ul>
<h3 id="4-base-理论了解吗"><a class="header" href="#4-base-理论了解吗">4. BASE 理论了解吗？</a></h3>
<p>BASE（Basically Available、Soft state、Eventual consistency）是基于 CAP 理论逐步演化而来的，核心思想是即便不能达到强一致性（Strong consistency），也可以根据应用特点采用适当的方式来达到最终一致性（Eventual consistency）的效果。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-6220689c-2cbc-447c-a313-2435943df0fe.jpg" alt="" /></p>
<p>BASE 的主要含义：</p>
<ul>
<li><strong>Basically Available（基本可用）</strong></li>
</ul>
<p>什么是基本可用呢？假设系统出现了不可预知的故障，但还是能用，只是相比较正常的系统而言，可能会有响应时间上的损失，或者功能上的降级。</p>
<ul>
<li><strong>Soft State（软状态）</strong></li>
</ul>
<p>什么是硬状态呢？要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态也称为弱状态，相比较硬状态而言，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p>
<ul>
<li><strong>Eventually Consistent（最终一致性）</strong></li>
</ul>
<p>上面说了软状态，但是不应该一直都是软状态。在一定时间后，应该到达一个最终的状态，保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间取决于网络延时、系统负载、数据复制方案设计等等因素。</p>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="分布式锁"><a class="header" href="#分布式锁">分布式锁</a></h2>
<p>单体时代，可以直接用本地锁来实现对竞争资源的加锁，分布式环境下就要用到分布式锁了。</p>
<h3 id="5-有哪些分布式锁的实现方案呢"><a class="header" href="#5-有哪些分布式锁的实现方案呢">5. 有哪些分布式锁的实现方案呢？</a></h3>
<p>常见的分布式锁实现方案有三种：<code>MySQL分布式锁</code>、<code>ZooKepper分布式锁</code>、<code>Redis分布式锁</code>。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-dba9586e-1e4c-44c9-9825-f117d5c10228.jpg" alt="" /></p>
<h4 id="51-mysql-分布式锁如何实现呢"><a class="header" href="#51-mysql-分布式锁如何实现呢">5.1 MySQL 分布式锁如何实现呢？</a></h4>
<p>用数据库实现分布式锁比较简单，就是创建一张锁表，数据库对字段作唯一性约束。</p>
<p>加锁的时候，在锁表中增加一条记录即可；释放锁的时候删除记录就行。</p>
<p>如果有并发请求同时提交到数据库，数据库会保证只有一个请求能够得到锁。</p>
<p>这种属于数据库 IO 操作，效率不高，而且频繁操作会增大数据库的开销，因此这种方式在高并发、高性能的场景中用的不多。</p>
<h4 id="52-zookeeper-如何实现分布式锁"><a class="header" href="#52-zookeeper-如何实现分布式锁">5.2 ZooKeeper 如何实现分布式锁？</a></h4>
<p>ZooKeeper 也是常见分布式锁实现方法。</p>
<p>ZooKeeper 的数据节点和文件目录类似，例如有一个 lock 节点，在此节点下建立子节点是可以保证先后顺序的，即便是两个进程同时申请新建节点，也会按照先后顺序建立两个节点。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-726d933e-3fa7-4458-ab70-41d09218535c.jpg" alt="" /></p>
<p>所以我们可以用此特性实现分布式锁。以某个资源为目录，然后这个目录下面的节点就是我们需要获取锁的客户端，每个服务在目录下创建节点，如果它的节点，序号在目录下最小，那么就获取到锁，否则等待。释放锁，就是删除服务创建的节点。</p>
<p>ZK 实际上是一个比较重的分布式组件，实际上应用没那么多了，所以用 ZK 实现分布式锁，其实相对也比较少。</p>
<h4 id="53-redis-怎么实现分布式锁"><a class="header" href="#53-redis-怎么实现分布式锁">5.3 Redis 怎么实现分布式锁？</a></h4>
<p>Redis 实现分布式锁，是当前应用最广泛的分布式锁实现方式。</p>
<p>Redis 执行命令是单线程的，Redis 实现分布式锁就是利用这个特性。</p>
<p>实现分布式锁最简单的一个命令：setNx(set if not exist)，如果不存在则更新：</p>
<pre><code>setNx resourceName value
</code></pre>
<p>加锁了之后如果机器宕机，那我这个锁就无法释放，所以需要加入过期时间，而且过期时间需要和 setNx 同一个原子操作，在 Redis2.8 之前需要用 lua 脚本，但是 redis2.8 之后 redis 支持 nx 和 ex 操作是同一原子操作。</p>
<pre><code>set resourceName value ex 5 nx
</code></pre>
<ul>
<li><strong>Redission</strong></li>
</ul>
<p>当然，一般生产中都是使用 Redission 客户端，非常良好地封装了分布式锁的 api，而且支持 RedLock。</p>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="分布式事务"><a class="header" href="#分布式事务">分布式事务</a></h2>
<h3 id="6什么是分布式事务"><a class="header" href="#6什么是分布式事务">6.什么是分布式事务?</a></h3>
<p>在分布式环境下，会涉及到多个数据库，比如说支付库、商品库、订单库。因此要保证跨服务的事务一致性就变得非常复杂。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-7e6aab86-57d4-49d5-91fd-14349b07a4c3.jpg" alt="三分恶面渣逆袭：多个数据库" /></p>
<p>分布式事务其实就是将单一库的事务概念扩大到了多库，目的是为了保证跨服的数据一致性。</p>
<h3 id="7分布式事务有哪些常见的实现方案"><a class="header" href="#7分布式事务有哪些常见的实现方案">7.分布式事务有哪些常见的实现方案？</a></h3>
<p>分布式事务的实现方式主要包括：</p>
<ul>
<li>二阶段提交（2PC）：通过准备和提交阶段保证一致性，但性能较差。</li>
<li>三阶段提交（3PC）：在 2PC 的基础上增加了一个超时机制，降低了阻塞，但依旧存在数据不一致的风险。</li>
<li>TCC：根据业务逻辑拆分为 Try、Confirm 和 Cancel 三个阶段，适合锁定资源的业务场景。</li>
<li>本地消息表：在数据库中存储事务事件，通过定时任务处理消息。</li>
<li>基于 MQ 的分布式事务：通过消息队列来实现异步确保，利用重试机制保障最终一致性，适用于对实时性要求不高的场景。</li>
</ul>
<h4 id="71-说说-2pc-两阶段提交"><a class="header" href="#71-说说-2pc-两阶段提交">7.1 说说 2PC 两阶段提交？</a></h4>
<p>说到 2PC，就不得先说分布式事务中的 XA 协议。</p>
<p>在这个协议里，有三个角色：</p>
<ul>
<li><strong>AP（Application）</strong>：应用系统（服务）</li>
<li><strong>TM（Transaction Manager）</strong>：事务管理器（全局事务管理）</li>
<li><strong>RM（Resource Manager）</strong>：资源管理器（数据库）</li>
</ul>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-7898a153-42a6-4133-be1e-1ccbe9f12540.jpg" alt="" /></p>
<p>XA 协议采用<strong>两阶段提交</strong>方式来管理分布式事务。XA 接口提供资源管理器与事务管理器之间进行通信的标准接口。</p>
<p>两阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是否要提交操作还是回滚操作。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-d7288027-b0c9-41ec-9ed4-c9d9091be7b9.jpg" alt="" /></p>
<ul>
<li>准备阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交</li>
<li>提交阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</li>
</ul>
<p>优点：尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于 MySQL 是从 5.5 开始支持。</p>
<p>缺点:</p>
<ul>
<li>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>
<li>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li>
<li>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务 commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>
</ul>
<h4 id="72-3pc三阶段提交了解吗"><a class="header" href="#72-3pc三阶段提交了解吗">7.2 3PC（三阶段提交）了解吗？</a></h4>
<p>三阶段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一种改进版本 ，为解决两阶段提交协议的单点故障和同步阻塞问题。</p>
<p>三阶段提交有这么三个阶段：<code>CanCommit</code>，<code>PreCommit</code>，<code>DoCommit</code>三个阶段</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-73061466-8f9c-44eb-9a3f-a41f4de98668.jpg" alt="" /></p>
<ul>
<li>
<p><strong>CanCommit</strong>：准备阶段。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p>
</li>
<li>
<p><strong>PreCommit</strong>：预提交阶段。协调者根据参与者在<strong>准备阶段</strong>的响应判断是否执行事务还是中断事务，参与者执行完操作之后返回 ACK 响应，同时开始等待最终指令。</p>
</li>
<li>
<p><strong>DoCommit</strong>：提交阶段。协调者根据参与者在<strong>准备阶段</strong>的响应判断是否执行事务还是中断事务：</p>
</li>
<li>
<p>如果所有参与者都返回正确的<code>ACK</code>响应，则提交事务</p>
</li>
<li>
<p>如果参与者有一个或多个参与者收到错误的<code>ACK</code>响应或者超时，则中断事务</p>
</li>
<li>
<p>如果参与者无法及时接收到来自协调者的提交或者中断事务请求时，在等待超时之后，会继续进行事务提交</p>
</li>
</ul>
<p>可以看出，三阶段提交解决的只是两阶段提交中<strong>单体故障</strong>和<strong>同步阻塞</strong>的问题，因为加入了超时机制，这里的超时的机制作用于 <strong>预提交阶段</strong> 和 <strong>提交阶段</strong>。如果等待 <strong>预提交请求</strong> 超时，参与者直接回到准备阶段之前。如果等到<strong>提交请求</strong>超时，那参与者就会提交事务了。</p>
<p><strong>无论是 2PC 还是 3PC 都不能保证分布式系统中的数据 100%一致</strong>。</p>
<h4 id="73-tcc-了解吗"><a class="header" href="#73-tcc-了解吗">7.3 TCC 了解吗？</a></h4>
<p><strong>TCC（Try Confirm Cancel）</strong> ，是两阶段提交的一个变种，针对每个操作，都需要有一个其对应的确认和取消操作，当操作成功时调用确认操作，当操作失败时调用取消操作，类似于二阶段提交，只不过是这里的提交和回滚是针对业务上的，所以基于 TCC 实现的分布式事务也可以看做是对业务的一种补偿机制。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-719faa5d-9709-43ff-8831-c6fa42c5d424.jpg" alt="" /></p>
<ul>
<li><strong>Try</strong>：尝试待执行的业务。订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于 1，然后将可用库存数量设置为库存剩余数量-1，。</li>
<li><strong>Confirm</strong>：确认执行业务，如果 Try 阶段执行成功，接着执行 Confirm 阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量。</li>
<li><strong>Cancel</strong>：取消待执行的业务，如果 Try 阶段执行失败，执行 Cancel 阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量。</li>
</ul>
<p><strong>TCC</strong> 是业务层面的分布式事务，保证最终一致性，不会一直持有资源的锁。</p>
<ul>
<li><strong>优点：</strong> 把数据库层的二阶段提交交给应用层来实现，规避了数据库的 2PC 性能低下问题</li>
<li><strong>缺点</strong>：TCC 的 Try、Confirm 和 Cancel 操作功能需业务提供，开发成本高。TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作</li>
</ul>
<h4 id="74-本地消息表了解吗"><a class="header" href="#74-本地消息表了解吗">7.4 本地消息表了解吗？</a></h4>
<p>本地消息表的核心思想是将分布式事务拆分成本地事务进行处理。</p>
<p>例如，可以在订单库新增一个消息表，将新增订单和新增消息放到一个事务里完成，然后通过轮询的方式去查询消息表，将消息推送到 MQ，库存服务去消费 MQ。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-73a460d6-90d7-493f-9fe9-1c6120952c47.jpg" alt="" /></p>
<p><strong>执行流程：</strong></p>
<ol>
<li>订单服务，添加一条订单和一条消息，在一个事务里提交</li>
<li>订单服务，使用定时任务轮询查询状态为未同步的消息表，发送到 MQ，如果发送失败，就重试发送</li>
<li>库存服务，接收 MQ 消息，修改库存表，需要保证幂等操作</li>
<li>如果修改成功，调用 rpc 接口修改订单系统消息表的状态为已完成或者直接删除这条消息</li>
<li>如果修改失败，可以不做处理，等待重试</li>
</ol>
<p>订单服务中的消息有可能由于业务问题会一直重复发送，所以为了避免这种情况可以记录一下发送次数，当达到次数限制之后报警，人工接入处理；库存服务需要保证幂等，避免同一条消息被多次消费造成数据不一致。</p>
<p>本地消息表这种方案实现了最终一致性，需要在业务系统里增加消息表，业务逻辑中多一次插入的 DB 操作，所以性能会有损耗，而且最终一致性的间隔主要有定时任务的间隔时间决定</p>
<h4 id="75-mq-消息事务了解吗"><a class="header" href="#75-mq-消息事务了解吗">7.5 MQ 消息事务了解吗？</a></h4>
<p>基于 MQ 的分布式事务是指<strong>将两个事务通过消息队列进行异步解耦</strong>，利用重试机制保障最终一致性，适用于对实时性要求不高的场景。</p>
<p>订单服务执行自己的本地事务，并发送消息到 MQ，库存服务接收到消息后，执行自己的本地事务，如果消费失败，可以利用重试机制确保最终一致性。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-b4cad82c-f9f9-407e-9e60-a2a35dd09b2f.jpg" alt="三分恶面渣逆袭：基于 MQ 的分布式事务" /></p>
<p>延迟队列在分布式事务中通常用于异步补偿、定时校验和故障重试等场景，确保数据最终一致性。</p>
<p>当主事务执行完成后，延迟队列会在一定时间后检查各子事务的状态，如果有失败的子事务，可以触发补偿操作，重试或回滚事务。</p>
<p>当分布式锁因为某些原因未被正常释放时，可以通过延迟队列在超时后自动释放锁，防止死锁。</p>
<h4 id="76-最大努力通知了解吗"><a class="header" href="#76-最大努力通知了解吗">7.6 最大努力通知了解吗？</a></h4>
<p>最大努力通知相比实现会简单一些，适用于一些对最终一致性实时性要求没那么高的业务，比如支付通知，短信通知。</p>
<p>以支付通知为例，业务系统调用支付平台进行支付，支付平台进行支付，进行操作支付之后支付平台会去同步通知业务系统支付操作是否成功，如果不成功，会一直异步重试，但是会有一个最大通知次数，如果超过这个次数后还是通知失败，就不再通知，业务系统自行调用支付平台提供一个查询接口，供业务系统进行查询支付操作是否成功。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-14edc9f7-2cbe-4790-95f4-97a3d0176c2c.jpg" alt="" /></p>
<p><strong>执行流程：</strong></p>
<ol>
<li>业务系统调用支付平台支付接口， 并在本地进行记录，支付状态为支付中</li>
<li>支付平台进行支付操作之后，无论成功还是失败，同步给业务系统一个结果通知</li>
<li>如果通知一直失败则根据重试规则异步进行重试，达到最大通知次数后，不再通知</li>
<li>支付平台提供查询订单支付操作结果接口</li>
<li>业务系统根据一定业务规则去支付平台查询支付结果</li>
</ol>
<h3 id="8你们用什么能说一下-seata-吗"><a class="header" href="#8你们用什么能说一下-seata-吗">8.你们用什么？能说一下 Seata 吗？</a></h3>
<p>我们用比较常用的是 Seata——自己去实现分布式事务调度还是比较麻烦的。</p>
<p><strong>Seata</strong> 的设计目标是对业务无侵入，因此它是从业务无侵入的两阶段提交（全局事务）着手，在传统的两阶段上进行改进，他把一个分布式事务理解成一个包含了若干分支事务的全局事务。而全局事务的职责是协调它管理的分支事务达成一致性，要么一起成功提交，要么一起失败回滚。也就是一荣俱荣一损俱损~</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-4ecb026d-2604-4fe4-9e7c-b2d328ce4356.jpg" alt="" /></p>
<p><strong>Seata</strong> 中存在这么几种重要角色：</p>
<ul>
<li><strong>TC（Transaction Coordinator）</strong>：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li>
<li><strong>TM（Transaction Manager）</strong>：事务管理者。用于开启、提交或回滚事务。</li>
<li><strong>RM（Resource Manager）</strong>：资源管理器。用于分支事务上的资源管理，向 <strong>TC</strong> 注册分支事务，上报分支事务的状态，接收 <strong>TC</strong> 的命令来提交或者回滚分支事务。</li>
</ul>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-68593970-056f-4334-864a-1f153a4278b1.jpg" alt="" /></p>
<p>Seata 整体执行流程：</p>
<ol>
<li>服务 A 中的 <strong>TM</strong> 向 <strong>TC</strong> 申请开启一个全局事务，<strong>TC</strong> 就会创建一个全局事务并返回一个唯一的 <strong>XID</strong></li>
<li>服务 A 中的 <strong>RM</strong> 向 <strong>TC</strong> 注册分支事务，然后将这个分支事务纳入 <strong>XID</strong> 对应的全局事务管辖中</li>
<li>服务 A 开始执行分支事务</li>
<li>服务 A 开始远程调用 B 服务，此时 <strong>XID</strong> 会根据调用链传播</li>
<li>服务 B 中的 <strong>RM</strong> 也向 <strong>TC</strong> 注册分支事务，然后将这个分支事务纳入 <strong>XID</strong> 对应的全局事务管辖中</li>
<li>服务 B 开始执行分支事务</li>
<li>全局事务调用处理结束后，<strong>TM</strong> 会根据有误异常情况，向 <strong>TC</strong> 发起全局事务的提交或回滚</li>
<li><strong>TC</strong> 协调其管辖之下的所有分支事务，决定是提交还是回滚</li>
</ol>
<blockquote>
<ol>
<li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html">Java 面试指南（付费）</a>收录的字节跳动同学 17 后端技术面试原题：分布式事务怎么实现 为什么要用延迟队列</li>
</ol>
</blockquote>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="分布式一致性算法"><a class="header" href="#分布式一致性算法">分布式一致性算法</a></h2>
<h3 id="9分布式算法-paxos-了解么-"><a class="header" href="#9分布式算法-paxos-了解么-">9.分布式算法 paxos 了解么 ？</a></h3>
<p><code>Paxos</code> 有点类似前面说的 <code>2PC</code>，<code>3PC</code>，但比这两种算法更加完善。在很多多大厂都得到了工程实践，比如阿里的 <code>OceanBase</code> 的 <strong>分布式数据库</strong>， <code>Google</code> 的 <code>chubby</code> <strong>分布式锁</strong> 。</p>
<h4 id="paxos-算法是什么"><a class="header" href="#paxos-算法是什么">Paxos 算法是什么？</a></h4>
<p><code>Paxos</code> 算法是 <strong>基于消息传递</strong> 且具有 <strong>高效容错特性</strong> 的一致性算法，目前公认的解决 <strong>分布式一致性问题</strong> 最有效的算法之一。</p>
<h4 id="paxos-算法的工作流程"><a class="header" href="#paxos-算法的工作流程">Paxos 算法的工作流程？</a></h4>
<h5 id="角色"><a class="header" href="#角色">角色</a></h5>
<p>在 Paxos 中有这么几个角色：</p>
<ol>
<li><strong>Proposer（提议者）</strong> : 提议者提出提案，用于投票表决。</li>
<li><strong>Accecptor（接受者）</strong> : 对提案进行投票，并接受达成共识的提案。</li>
<li><strong>Learner（学习者）</strong> : 被告知投票的结果，接受达成共识的提案。</li>
</ol>
<p>在实际中，一个节点可以同时充当不同角色。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-e791ca85-9d8b-4beb-b7dd-8e23ed5c9ec4.jpg" alt="" /></p>
<p>提议者提出提案，提案=编号+value，可以表示为[M,V]，每个提案都有唯一编号，而且编号的大小是趋势递增的。</p>
<h5 id="算法流程"><a class="header" href="#算法流程">算法流程</a></h5>
<p>Paxos 算法包含两个阶段，第一阶段 <strong>Prepare(准备)</strong> 、第二阶段 <strong>Accept(接受)</strong> 。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-89545387-0043-4cb6-a178-5bd7330ee4ba.jpg" alt="" /></p>
<h6 id="prepare准备阶段"><a class="header" href="#prepare准备阶段">Prepare(准备)阶段</a></h6>
<ol>
<li>提议者提议一个新的提案 P[Mn,?]，然后向接受者的某个超过半数的子集成员发送编号为 Mn 的准备请求</li>
<li>如果一个接受者收到一个编号为 Mn 的准备请求，并且编号 Mn 大于它已经响应的所有准备请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给提议者，同时该接受者会承诺不会再批准任何编号小于 Mn 的提案。</li>
</ol>
<p>总结一下，接受者在收到提案后，会给与提议者<strong>两个承诺</strong>与<strong>一个应答</strong>：</p>
<ul>
<li>
<p>两个承诺：</p>
</li>
<li>
<p>承诺不会再接受提案号小于或等于 Mn 的 Prepare 请求</p>
</li>
<li>
<p>承诺不会再接受提案号小于 Mn 的 Accept 请求</p>
</li>
<li>
<p>一个应答：</p>
</li>
<li>
<p>不违背以前作出的承诺的前提下，回复已经通过的提案中提案号最大的那个提案所设定的值和提案号 Mmax，如果这个值从来没有被任何提案设定过，则返回空值。如果不满足已经做出的承诺，即收到的提案号并不是决策节点收到过的最大的，那允许直接对此 Prepare 请求不予理会。</p>
</li>
</ul>
<h6 id="accept接受阶段"><a class="header" href="#accept接受阶段">Accept(接受)阶段</a></h6>
<ol>
<li>如果提议者收到来自半数以上的接受者对于它发出的编号为 Mn 的准备请求的响应，那么它就会发送一个针对[Mn,Vn]的接受请求给接受者，注意 Vn 的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它可以随意选定一个值。</li>
<li>如果接受者收到这个针对[Mn,Vn]提案的接受请求，只要该接受者尚未对编号大于 Mn 的准备请求做出响应，它就可以通过这个提案。</li>
</ol>
<p>当提议者收到了多数接受者的接受应答后，协商结束，共识决议形成，将形成的决议发送给所有学习节点进行学习。</p>
<p>所以 Paxos 算法的整体详细流程如下：</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-53377006-1d4d-4b55-93d1-d4138339044c.jpg" alt="" /></p>
<h4 id="paxos-算法有什么缺点吗怎么优化"><a class="header" href="#paxos-算法有什么缺点吗怎么优化">Paxos 算法有什么缺点吗？怎么优化？</a></h4>
<p>前面描述的可以称之为 Basic Paxos 算法，在单提议者的前提下是没有问题的，但是假如有多个提议者互不相让，那么就可能导致整个提议的过程进入了死循环。</p>
<p>Lamport 提出了 Multi Paxos 的算法思想。</p>
<p>Multi Paxos 算法思想，简单说就是在多个提议者的情况下，选出一个 Leader（领导者），由领导者作为唯一的提议者，这样就可以解决提议者冲突的问题。</p>
<h3 id="10说说-raft-算法"><a class="header" href="#10说说-raft-算法">10.说说 Raft 算法？</a></h3>
<h4 id="raft-算法是什么"><a class="header" href="#raft-算法是什么">Raft 算法是什么？</a></h4>
<p><code>Raft</code> 也是一个 <strong>一致性算法</strong>，和 <code>Paxos</code> 目标相同。但它还有另一个名字 - <strong>易于理解的一致性算法</strong>。<code>Paxos</code> 和 <code>Raft</code> 都是为了实现 <strong>一致性</strong> 产生的。这个过程如同选举一样，<strong>参选者</strong> 需要说服 <strong>大多数选民</strong> (Server) 投票给他，一旦选定后就跟随其操作。<code>Paxos</code> 和 <code>Raft</code> 的区别在于选举的 <strong>具体过程</strong> 不同。</p>
<h4 id="raft-算法的工作流程"><a class="header" href="#raft-算法的工作流程">Raft 算法的工作流程？</a></h4>
<h5 id="raft-算法的角色"><a class="header" href="#raft-算法的角色">Raft 算法的角色</a></h5>
<p><code>Raft</code> 协议将 <code>Server</code> 进程分为三种角色：</p>
<ul>
<li><strong>Leader（领导者）</strong></li>
<li><strong>Follower（跟随者）</strong></li>
<li><strong>Candidate（候选人）</strong></li>
</ul>
<p>就像一个民主社会，领导者由跟随者投票选出。刚开始没有 <strong>领导者</strong>，所有集群中的 <strong>参与者</strong> 都是 <strong>跟随者</strong>。</p>
<p>那么首先开启一轮大选。在大选期间 <strong>所有跟随者</strong> 都能参与竞选，这时所有跟随者的角色就变成了 <strong>候选人</strong>，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 <strong>领导者</strong> 的 <strong>候选人</strong> 又变回 <strong>跟随者</strong> 服从领导者领导。</p>
<p>这里提到一个概念 <strong>「任期」</strong>，用术语 <code>Term</code> 表达。</p>
<p>三类角色的变迁图如下：</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-ef4dd655-1693-485f-aca6-494b89dfb57b.jpg" alt="" /></p>
<h5 id="leader-选举过程"><a class="header" href="#leader-选举过程">Leader 选举过程</a></h5>
<p>Raft 使用心跳（heartbeat）触发 Leader 选举。当 Server 启动时，初始化为 Follower。Leader 向所有 Followers 周期性发送 heartbeat。如果 Follower 在选举超时时间内没有收到 Leader 的 heartbeat，就会等待一段随机的时间后发起一次 Leader 选举。</p>
<p>Follower 将其当前 term 加一然后转换为 Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC 。结果有以下三种情况：</p>
<ul>
<li>赢得了多数（超过 1/2）的选票，成功选举为 Leader；</li>
<li>收到了 Leader 的消息，表示有其它服务器已经抢先当选了 Leader；</li>
<li>没有 Server 赢得多数的选票，Leader 选举失败，等待选举时间超时（<code>Election Timeout</code>）后发起下一次选举。</li>
</ul>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-996430a8-29f7-4c40-82b6-e4e33316289c.jpg" alt="" /></p>
<p>选出 <code>Leader</code> 后，<code>Leader</code> 通过 <strong>定期</strong> 向所有 <code>Follower</code> 发送 <strong>心跳信息</strong> 维持其统治。若 <code>Follower</code> 一段时间未收到 <code>Leader</code> 的 <strong>心跳</strong>，则认为 <code>Leader</code> 可能已经挂了，然后再次发起 <strong>选举</strong> 过程。</p>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="分布式设计"><a class="header" href="#分布式设计">分布式设计</a></h2>
<h3 id="11说说什么是幂等性"><a class="header" href="#11说说什么是幂等性">11.说说什么是幂等性？</a></h3>
<blockquote>
<p>什么是幂等性？</p>
</blockquote>
<p>幂等性是一个数学概念，用在接口上：用在接口上就可以理解为：<strong>同一个接口，多次发出同一个请求，请求的结果是一致的。</strong></p>
<p>简单说，就是多次调用如一次。</p>
<blockquote>
<p>什么是幂等性问题？</p>
</blockquote>
<p>在系统的运行中，可能会出现这样的问题：</p>
<ol>
<li>用户在填写某些<code>form表单</code>时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是 id 不一样。</li>
<li>开发人员在项目中为了解决<code>接口超时</code>问题，通常会引入了<code>重试机制</code>。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），于是会对该请求重试几次，这样也会产生重复的数据。</li>
<li>mq 消费者在读取消息时，有时候会读取到<code>重复消息</code>，也会产生重复的数据。</li>
</ol>
<p>这些都是常见的幂等性问题。</p>
<p>在分布式系统里，只要下游服务有写（保存、更新）的操作，都有可能会产生幂等性问题。</p>
<p>PS:幂等和防重有些不同，防重强调的防止数据重复，幂等强调的是多次调用如一次，防重包含幂等。</p>
<h3 id="怎么保证接口幂等性"><a class="header" href="#怎么保证接口幂等性">怎么保证接口幂等性？</a></h3>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-91db1e86-9bc6-4b58-9c42-e6541d04c5b8.jpg" alt="" /></p>
<ol>
<li>insert 前先 select</li>
</ol>
<p>在保存数据的接口中，在<code>insert</code>前，先根据<code>requestId</code>等字段先<code>select</code>一下数据。如果该数据已存在，则直接返回，如果不存在，才执行  <code>insert</code>操作。</p>
<ol start="2">
<li>加唯一索引</li>
</ol>
<p>加唯一索引是个非常简单但很有效的办法，如果重复插入数据的话，就会抛出异常，为了保证幂等性，一般需要捕获这个异常。</p>
<p>如果是<code>java</code>程序需要捕获：<code>DuplicateKeyException</code>异常，如果使用了<code>spring</code>框架还需要捕获：<code>MySQLIntegrityConstraintViolationException</code>异常。</p>
<ol start="3">
<li>加悲观锁</li>
</ol>
<p>更新逻辑，比如更新用户账户余额，可以加悲观锁，把对应用户的哪一行数据锁住。同一时刻只允许一个请求获得锁，其他请求则等待。</p>
<pre><code>select * from user id=123 for update;
</code></pre>
<p>这种方式有一个缺点，获取不到锁的请求一般只能报失败，比较难保证接口返回相同值。</p>
<ol start="4">
<li>加乐观锁</li>
</ol>
<p>更新逻辑，也可以用乐观锁，性能更好。可以在表中增加一个<code>timestamp</code>或者<code>version</code>字段，例如<code>version</code>:</p>
<p>在更新前，先查询一下数据，将 version 也作为更新的条件，同时也更新 version：</p>
<pre><code>update user set amount=amount+100,version=version+1 where id=123 and version=1;
</code></pre>
<p>更新成功后，version 增加，重复更新请求进来就无法更新了。</p>
<ol start="5">
<li>建防重表</li>
</ol>
<p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，就可以使用防重表的方式。</p>
<p>例如消息消费中，创建防重表，存储消息的唯一 ID，消费时先去查询是否已经消费，已经消费直接返回成功。</p>
<ol start="6">
<li>状态机</li>
</ol>
<p>有些业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态，可以通过限制状态的流动来完成幂等。</p>
<ol start="7">
<li>分布式锁</li>
</ol>
<p>直接在数据库上加锁的做法性能不够友好，可以使用分布式锁的方式，目前最流行的分布式锁实现是通过 Redis，具体实现一般都是使用 Redission 框架。</p>
<ol start="8">
<li>token 机制</li>
</ol>
<p>请求接口之前，需要先获取一个唯一的 token，再带着这个 token 去完成业务操作，服务端根据这个 token 是否存在，来判断是否是重复的请求。</p>
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>
<h2 id="分布式限流"><a class="header" href="#分布式限流">分布式限流</a></h2>
<h3 id="12你了解哪些限流算法"><a class="header" href="#12你了解哪些限流算法">12.你了解哪些限流算法？</a></h3>
<ul>
<li>计数器</li>
</ul>
<p>计数器比较简单粗暴，比如我们要限制 1s 能够通过的请求数，实现的思路就是从第一个请求进来开始计时，在接下来的 1s 内，每个请求进来请求数就+1，超过最大请求数的请求会被拒绝，等到 1s 结束后计数清零，重新开始计数。</p>
<p>这种方式有个很大的弊端：比如前 10ms 已经通过了最大的请求数，那么后面的 990ms 的请求只能拒绝，这种现象叫做“突刺现象”。</p>
<ul>
<li>漏桶算法</li>
</ul>
<p>就是桶底出水的速度恒定，进水的速度可能快慢不一，但是当进水量大于出水量的时候，水会被装在桶里，不会直接被丢弃；但是桶也是有容量限制的，当桶装满水后溢出的部分还是会被丢弃的。</p>
<p><strong>算法实现</strong>：可以准备一个队列来保存暂时处理不了的请求，然后通过一个线程池定期从队列中获取请求来执行。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-32b12c10-9b9a-45f1-af72-a6446223fb21.jpg" alt="" /></p>
<ul>
<li>令牌桶算法</li>
</ul>
<p>令牌桶就是生产访问令牌的一个地方，生产的速度恒定，用户访问的时候当桶中有令牌时就可以访问，否则将触发限流。</p>
<p><strong>实现方案</strong>：Guava RateLimiter 限流</p>
<p>Guava RateLimiter 是一个谷歌提供的限流，其基于令牌桶算法，比较适用于单实例的系统。</p>
<p><img src="http://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene//fenbushi-b80e74ed-9b0a-4327-9ea0-3bef4da76634.jpg" alt="" /></p>
<p>这一期的分布式面试题就整理到这里了，主要是偏理论的一些问题，分布式其实是个很大的类型，比如分布式调用、分布式治理……</p>
<p>所以，这篇文章只是个开始，后面还会有分布式调用（RPC）、微服务相关的主题文章，敬请期待。</p>
<blockquote>
<p>图文详解 12 道分布式面试高频题，这次面试，一定吊打面试官，整理：沉默王二，戳<a href="https://mp.weixin.qq.com/s/nLwHEmVGtl-2FDugMqYs3A">转载链接</a>，作者：三分恶，戳<a href="https://mp.weixin.qq.com/s/d84tWIjbcGKhwUptzkO2hQ">原文链接</a>。</p>
</blockquote>
<hr />
<p><em>没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟</em>。</p>
<p><strong>系列内容</strong>：</p>
<ul>
<li><a href="https://javabetter.cn/sidebar/sanfene/javase.html">面渣逆袭 Java SE 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/javathread.html">面渣逆袭 Java 集合框架篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/collection.html">面渣逆袭 Java 并发编程篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/jvm.html">面渣逆袭 JVM 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/spring.html">面渣逆袭 Spring 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/redis.html">面渣逆袭 Redis 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/mybatis.html">面渣逆袭 MyBatis 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/mysql.html">面渣逆袭 MySQL 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/os.html">面渣逆袭操作系统篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/network.html">面渣逆袭计算机网络篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/rocketmq.html">面渣逆袭 RocketMQ 篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/fenbushi.html">面渣逆袭分布式篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/weifuwu.html">面渣逆袭微服务篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/shejimoshi.html">面渣逆袭设计模式篇 👍</a></li>
<li><a href="https://javabetter.cn/sidebar/sanfene/linux.html">面渣逆袭 Linux 篇 👍</a></li>
</ul>
<hr />
<p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer">二哥的 Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p>
<p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>222</strong> 即可免费领取。</p>
<p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt="" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="rocketmq.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="nixi.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="rocketmq.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="nixi.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
